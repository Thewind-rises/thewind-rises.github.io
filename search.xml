<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>iptables使用记录（害人不浅）</title>
      <link href="/posts/41482.html"/>
      <url>/posts/41482.html</url>
      
        <content type="html"><![CDATA[<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>TMD今天在一台内网设备上给人开防火墙策略，结果少了一个插件导致无法直接save，重启了iptables服务之后之前别人配好的策略没了，当场给我吓一跳。所幸后来还是根据之前查看的列表恢复了过来，不然就要提桶跑路了。<br>虽然到最后还是因为未知原因导致那边没办法访问服务，乐死了。</p><h2 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h2><p>显示所有规则： <code>iptables -L --line </code></p><p>配置文件地址： <code>/etc/sysconfig/iptables </code></p><p>指定行号添加规则： <code>iptables -I  INPUT “指定号” -s “IP地址” -p “协议（不写-p的话就是所有都可）” --dport “端口号”（目的端口，删除的话不限制端口） -j ACCEPT（DROP为禁用）</code></p><p>删除规则（根据行号）： <code>iptables -D INPUT “行号” </code></p><p>指定行号修改规则： <code>iptables -R  INPUT “指定号” -s “IP地址” -p “协议（不写-p的话就是所有都可）” --dport “端口号”（目的端口，删除的话不限制端口） -j ACCEPT（DROP为禁用） </code></p><p>修改之后记得保存： <code>service iptables save </code></p><p>其实挺蠢的，不保存重启就莫得了，保存的话内网机器不一定能用SAVE选项，还是只能写文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更换VsCode编辑器测试</title>
      <link href="/posts/12335.html"/>
      <url>/posts/12335.html</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>很可惜，Typora最终还是选择了收费，但是写软件本来就是可以恰钱的，这点实在是无可指摘。在试用了Marktext编辑器之后，发现其对于图片的处理十分的愚蠢，不能自定义图片大小（虽然MarkDown语法本身没有原生支持），不能设置图片名称，上传不能自定义参数全靠意念手搓，复制图片链接也不能快捷转化为MarkDown语法的链接。Atom编辑器之前也使用过，可以装一大堆插件确实很不错，但是对于系统资源的开销属实是有点大了，而且打开速度随着插件越来越多变的越来越慢。</p><p>林林总总看了一圈，最后还是选择了Vscode。装上了对应的插件之后，<del>也不是不能用</del>还挺好用的，就是得之后调节成浅色主题，深色看起来也不酷，而且让人觉得很郁郁。<br><img src="https://fishbed.easy233.top/%E6%9B%B4%E6%8D%A2VsCode%E7%BC%96%E8%BE%91%E5%99%A8%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95.png" alt="测试样例">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在十五天内过英语四级</title>
      <link href="/posts/15672.html"/>
      <url>/posts/15672.html</url>
      
        <content type="html"><![CDATA[<h2 id="如何在十五天之内过英语四级"><a href="#如何在十五天之内过英语四级" class="headerlink" title="如何在十五天之内过英语四级"></a>如何在十五天之内过英语四级</h2><p><img src="https://fishbed.easy233.top/e372cffbf7e8e23289c2d9a4b651f8a9.jpeg" alt="College English Test"></p><p><del>哈哈哈哈艹，拖延症晚期吃你家大米啦。</del></p><p>u1s1，如果是大一就让我能直接考四级，我裸考都可以，现在让我考四级。OK，让我们翻开第一个单词，abadon!!!</p><p>笑死，根本不会拼。</p><p>abandon v. 遗弃；离开；放弃；终止；陷入</p><p><del>到底为什么学校不让大一就考，而且还要抢名额啊！抢名额你好歹升级一下服务器行不行啊！跟TM教务信息管理系统一样垃圾。呵，tui</del></p><p>目测今年六月份这次就是我最后机会了，再没有就真的“寄”了。</p><h3 id="分数分布"><a href="#分数分布" class="headerlink" title="分数分布"></a>分数分布</h3><ul><li><p>写作 15%</p></li><li><p>听力 30%</p></li><li><p>阅读 35%</p></li><li><p>翻译 15%</p></li></ul><h3 id="得分分布"><a href="#得分分布" class="headerlink" title="得分分布"></a>得分分布</h3><ul><li>写作 拿11%分数</li><li>听力 拿15%以上分数（<del>考虑到本身听力还可以</del>）</li><li>阅读 拿25%左右分数</li><li>翻译 拿9%分数</li></ul><p>总计预计能拿60%以上分数，不过还是设立目标为70%以上吧。</p><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ol><li>词汇量不足（<del>讲个笑话，abanddon</del>）</li><li>语法不会</li><li>语感基本没了（<del>实际上这点最致命，以前没背过语法英语拿个一百一二还是可以的</del>）</li><li>懒狗（啧）</li></ol><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><h4 id="作文"><a href="#作文" class="headerlink" title="作文"></a>作文</h4><h5 id="每天精做一个作文题"><a href="#每天精做一个作文题" class="headerlink" title="每天精做一个作文题"></a>每天精做一个作文题</h5><p>要求：</p><p>掐表做题。25分钟内完成</p><p>从答案摘抄2~3个句子</p><h5 id="泛做3篇作文题"><a href="#泛做3篇作文题" class="headerlink" title="泛做3篇作文题"></a>泛做3篇作文题</h5><p>要求：</p><p>先看题目，构思三分钟</p><p>直接看答案，和构思对比</p><h4 id="听力"><a href="#听力" class="headerlink" title="听力"></a>听力</h4><ol><li>找3套听力真题精听（找到听力原文，反复听，直到每个单词都认识为止）</li><li>泛听其他题</li></ol><h4 id="阅读："><a href="#阅读：" class="headerlink" title="阅读："></a>阅读：</h4><ol><li>选词填空：每天一套题，背单词</li><li>段落匹配：慢速练习，熟练后加快做题速度</li><li>仔细阅读：习惯复习</li></ol><h4 id="背单词："><a href="#背单词：" class="headerlink" title="背单词："></a>背单词：</h4><ul><li><p>从核心词汇/高频词汇开始背</p></li><li><p>通过试卷背单词</p></li><li><p>推荐泛背单词用A4纸记忆法，本人亲测确实有用</p></li></ul><h4 id="The-END"><a href="#The-END" class="headerlink" title="The END"></a>The END</h4><p><img src="https://fishbed.easy233.top/image-20210907160102497.png" alt="听力救我于水火！"></p><p>祝大家伙儿都能过四级嗷！</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.bilibili.com/video/BV1ZJ411d7hJ?from=search&seid=657951963363513466&spm_id_from=333.337.0.0">【纯干货】10天过英语四级的复习方法_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1g7411T7Py/?spm_id_from=333.788.recommend_more_video.-1">【学英语】北大学姐的高效背单词法！不看亏大了！1小时竟能背100多个？_哔哩哔哩_bilibili</a></p><p>嫖的三套2019年星火英语上的四级真题</p>]]></content>
      
      
      
        <tags>
            
            <tag> 英语四级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客说明书（观前必看）</title>
      <link href="/posts/3801.html"/>
      <url>/posts/3801.html</url>
      
        <content type="html"><![CDATA[<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>之所以有这个博客，是我想要记录我的学习经历，以及在这个世界上留下自己的一点痕迹，毕竟来这世上走一遭，要是什么都没留下未免太过遗憾。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>此博客：</p><ul><li>使用HEXO框架搭建</li><li>托管在Githubpage</li><li>主题使用Matery</li><li>内容为自己胡编乱造不保证绝对正确，但是凑合看看估计还行</li><li>域名嫖的Githubpage</li><li>图床嫖的七牛云（虽然付费了HTTPS流量，不过连TLS证书都是嫖的，笑死，根本嫖不完）</li><li>图床外链嫖的EASY大佬的子域名</li><li>MarkDown编辑器嫖的<del>Typora</del>VsCode</li><li>评论区嫖的腾讯兔小巢</li><li><del>可谓极尽白嫖之能事</del></li></ul><p>在搭建过程中得到了各路大佬的帮助，也查了很多网上的博客，很多都是很优质的文章，但是数目太多就不一一列举了。</p><p><strong>非常感谢！</strong></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>因为担心各种权限问题以及懒（这个主要），所以博客评论使用了兔小巢，但是入口很难找说实话（我部署上的时候也找了一阵子），所以这里直接说明位置，方便得到反馈。<br><img src="https://fishbed.easy233.top/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E%E4%B9%A6/%E4%BD%8D%E7%BD%AE.png" alt="位置">  </p><p>点开之后就会跳转到腾讯兔小巢，可以直接使用QQ登录进行留言。<br><img src="https://fishbed.easy233.top/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E%E4%B9%A6/%E5%85%94%E5%B0%8F%E5%B7%A2.png" alt="兔小巢">  </p><p>u1s1，这个简洁页面还挺好看，没有广告实在是太好了。</p><p><del>最好的地方是能白嫖。</del></p><p>好耶！好耶！！好耶！！！</p><img src="https://fishbed.easy233.top/QQ图片20210402102641.jpg" alt="声明" style="zoom: 33%;" />]]></content>
      
      
      
        <tags>
            
            <tag> 必看 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好耶！得到了大佬支援博客恢复啦</title>
      <link href="/posts/42575.html"/>
      <url>/posts/42575.html</url>
      
        <content type="html"><![CDATA[<img src="https://fishbed.easy233.top/u=3763831600,2691213973&fm=11&gp=0.jpg" alt="好耶！好耶！好耶！" style="zoom:200%;" /><p>如题所述，EASY大佬给我嫖了一个他的域名的子域名。</p><p>比较值得记录的是因为需要替换的图片比较多，所以使用了Python脚本来实现所有的修改。</p><blockquote><p>科学技术是第一生产力（确信）</p></blockquote><p>本来打算自己写的，但是随手去网上搜了一下发现了非常合用的就直接修改了一下拿来用了。</p><p>这里也记录一下。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> re<span class="token keyword">import</span> os<span class="token keyword">def</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    i <span class="token operator">=</span> <span class="token number">0</span>    path <span class="token operator">=</span> <span class="token string">r"D:/Demo/HEXO/source/_posts/"</span>    filelist <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>path<span class="token punctuation">)</span>  <span class="token comment"># 该文件夹下所有文件（包括文件夹）</span>    <span class="token keyword">for</span> files <span class="token keyword">in</span> filelist<span class="token punctuation">:</span>  <span class="token comment"># 遍历所有文件</span>        i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        Olddir <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>path<span class="token punctuation">,</span> files<span class="token punctuation">)</span>  <span class="token comment"># 原来的文件路径</span>        <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>Olddir<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        filename <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>splitext<span class="token punctuation">(</span>files<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        filetype <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>splitext<span class="token punctuation">(</span>files<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        filepath <span class="token operator">=</span> path <span class="token operator">+</span> filename <span class="token operator">+</span> filetype        alter<span class="token punctuation">(</span>filepath<span class="token punctuation">,</span> <span class="token string">"ero.bw-blog.top"</span><span class="token punctuation">,</span> <span class="token string">"fishbed.easy233.top"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">alter</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> old_str<span class="token punctuation">,</span> new_str<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f1<span class="token punctuation">,</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"%s.bak"</span> <span class="token operator">%</span> <span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f2<span class="token punctuation">:</span>        <span class="token keyword">for</span> line <span class="token keyword">in</span> f1<span class="token punctuation">:</span>            <span class="token keyword">if</span> old_str <span class="token keyword">in</span> line<span class="token punctuation">:</span>                line <span class="token operator">=</span> line<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>old_str<span class="token punctuation">,</span> new_str<span class="token punctuation">)</span>            f2<span class="token punctuation">.</span>write<span class="token punctuation">(</span>line<span class="token punctuation">)</span>    os<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span>    os<span class="token punctuation">.</span>rename<span class="token punctuation">(</span><span class="token string">"%s.bak"</span> <span class="token operator">%</span> <span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token builtin">file</span><span class="token punctuation">)</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python确实香，半年多没写Python脚本看了几眼就知道这个脚本运作原理了，如果是个C语言的程序我TM直接自闭。</p><p>以上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图床修复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>悲报！图床域名被冻结了，图片全部木大</title>
      <link href="/posts/43684.html"/>
      <url>/posts/43684.html</url>
      
        <content type="html"><![CDATA[<p>​    因为一些不可抗力因素（栋梁哥没钱续费服务器导致域名备案不通过），博客图床所使用的域名被冻结，在我找到新的能嫖的域名之前博客图片将暂时无法访问。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 悲报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非硬核向-Kerberos权限认证部分细节及深入了解MS14-068</title>
      <link href="/posts/36855.html"/>
      <url>/posts/36855.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://fishbed.easy233.top/MS14-068%20mimikatz.jpg" alt="MS14-068 mimikatz"></p><p>在上篇文章（<a href="https://thewind-rises.github.io/posts/42406.html">传送门</a>）中我已经写了Kerberos的认证流程，如果仔细看过的话我相信你应该已经建立起了对Kerberos认证正常流程的认识。这篇文章主要是为了更深一步挖掘Kerberos协议的细节，以及简单讲讲MS14-068这个漏洞的原理。</p><h2 id="Kerberos协议细节"><a href="#Kerberos协议细节" class="headerlink" title="Kerberos协议细节"></a>Kerberos协议细节</h2><p>之前在写Kerberos流程的时候我只是讲了身份认证，对于权限认证的事情没有说那么多，只是简单地一笔带过</p><p><img src="https://fishbed.easy233.top/image-20201109173828603.png" alt="一点细节"></p><p>这次在研究MS14-068的时候涉及到了这方面，也就拿出来单独讲讲。</p><h3 id="PAC"><a href="#PAC" class="headerlink" title="PAC"></a>PAC</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>PAC（Privilege Attribute Certificate），翻译过来就是特权属性证书。PAC是微软在Windows平台上对Kerberos协议的扩充，其设计目的就是为了解决服务器对用户的权限认证问题。因为Kerberos只是解决了身份认证，并没有实现对于访问权限的认证。</p><p>也就是说Kerberos只是让服务器确定了访问用户的身份，但是不能让服务器知道用户是否有访问这个服务的对应权限。这对于域的管理是很不利的。而如果要求服务器在验证完Client的身份之后还要向KDC发出请求来确认Client的权限，那对于KDC又是一个负担。</p><p>因此微软在Kerberos中又引入了PAC来解决这个问题。</p><p>类似于Linux对于用户权限的管理，在Windows域中，每一个用户也拥有自己的SID和所在组的GID，正是通过SID和GID才能使得Server确定Client的权限。</p><p>但是Kerberos中有一个背景就是<strong>假定网络上传送的数据包可以被任意地读取、修改和插入数据</strong>。所以说在Client，Server，KDC这三者中，Server只信任KDC的信息，而且KDC中也的确保存着Client和Server的权限。</p><blockquote><p>PS:（因为KDC在Kerberos协议中就扮演着可信第三方的身份，如果连KDC都不可信，那域信任就无从谈起）</p></blockquote><p>所以说，现在的问题就是，KDC如何把Client的权限信息安全的发送给Server。毕竟只有验证权限之后Server才能给Client提供服务。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="https://fishbed.easy233.top/image-20201109193249085.png" alt="PAC"></p><p>PAC有着自己严密的数据结构，但是正如这篇文章的标题：非硬核向。所以我只讲和MS14-068相关的一部分（毕竟你让我讲别的我也说不出来）。对内部细节感兴趣的可以看我列在参考文章中的博客。</p><table><thead><tr><th align="center">类型</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">0x00000001</td><td align="center">登录信息。PAC结构必须包含一个这种类型的缓冲区。其他登录信息缓冲区必须被忽略。</td></tr><tr><td align="center">0x0000000A</td><td align="center">客户名称和票证信息。PAC结构必须包含一个这种类型的缓冲区。附加的客户和票据信息缓冲区必须被忽略。</td></tr><tr><td align="center">0x00000006</td><td align="center">服务器校验和。PAC结构必须包含一个这种类型的缓冲区。其他登录服务器校验和缓冲区必须被忽略。</td></tr><tr><td align="center">0x00000007</td><td align="center">KDC校验和。PAC结构必须包含一个这种类型的缓冲区。附加的KDC校验和缓冲区必须被忽略。</td></tr></tbody></table><blockquote><p>我不知道上面的表格内容你们看明白没，反正我是有点懵逼</p></blockquote><h5 id="0x00000001-KERB-VALIDATION-INFO"><a href="#0x00000001-KERB-VALIDATION-INFO" class="headerlink" title="0x00000001 KERB_VALIDATION_INFO"></a>0x00000001 KERB_VALIDATION_INFO</h5><p>validation n.生效；批准；验证；确认；证实；核实</p><p>这一部分是登录信息，也是PAC最重要的部分，如果被修改的话就会出现大问题。（虽然一般情况下不可能，但是有了MS14-068）</p><p>KERB_VALIDATION_INFO是一个条目巨多的结构体，但是最关键的地方就在SID和GID。</p><pre class="line-numbers language-none"><code class="language-none">typedef struct _KERB_VALIDATION_INFO &#123;FILETIME LogonTime;FILETIME LogoffTime;FILETIME KickOffTime;FILETIME PasswordLastSet;FILETIME PasswordCanChange;FILETIME PasswordMustChange;RPC_UNICODE_STRING EffectiveName;RPC_UNICODE_STRING FullName;RPC_UNICODE_STRING LogonScript;RPC_UNICODE_STRING ProfilePath;RPC_UNICODE_STRING HomeDirectory;RPC_UNICODE_STRING HomeDirectoryDrive;USHORT LogonCount;USHORT BadPasswordCount;ULONG UserId; &#x2F;&#x2F;用户的sidULONG PrimaryGroupId;ULONG GroupCount;[size_is(GroupCount)] PGROUP_MEMBERSHIP GroupIds;&#x2F;&#x2F;用户所在的组，如果我们可以篡改的这个的话，添加一个500(域管组)，那用户就是域管了。在ms14068 PAC签名被绕过，用户可以自己制作PAC的情况底下，pykek就是靠向这个地方写进域管组，成为使得改用户变成域管ULONG UserFlags;USER_SESSION_KEY UserSessionKey;RPC_UNICODE_STRING LogonServer;RPC_UNICODE_STRING LogonDomainName;PISID LogonDomainId;ULONG Reserved1[2];ULONG UserAccountControl;ULONG SubAuthStatus;FILETIME LastSuccessfulILogon;FILETIME LastFailedILogon;ULONG FailedILogonCount;ULONG Reserved3;ULONG SidCount;[size_is(SidCount)] PKERB_SID_AND_ATTRIBUTES ExtraSids;PISID ResourceGroupDomainSid;ULONG ResourceGroupCount;[size_is(ResourceGroupCount)] PGROUP_MEMBERSHIP ResourceGroupIds;&#125; KERB_VALIDATION_INFO;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="0x0000000A-PAC-CLIENT-INFO"><a href="#0x0000000A-PAC-CLIENT-INFO" class="headerlink" title="0x0000000A PAC_CLIENT_INFO"></a>0x0000000A PAC_CLIENT_INFO</h5><p>ClientId（8个字节）</p><ul><li>包含在Kerberos初始TGT的authtime</li></ul><p>NameLength（2字节）</p><ul><li>用于指定Name 字段的长度（以字节为单位）。</li></ul><p>Name</p><ul><li>包含客户帐户名的16位Unicode字符数组，格式为低端字节序。</li></ul><p><img src="https://fishbed.easy233.top/image-20201109200641517.png" alt="官方Doc文档"></p><blockquote><p>官方提供的Docs文档居然没有中文，怪不得中文互联网上讲Kerberos内部细节的文章那么少。</p></blockquote><h5 id="0x00000006-Server-Signature"><a href="#0x00000006-Server-Signature" class="headerlink" title="0x00000006 Server Signature"></a>0x00000006 Server Signature</h5><p>由KDC用提供服务的账户（也就是server hash或者是krbtgt hash，取决于REQ包中Sname字段）进行签名，数字签名，防止PAC内容被篡改。</p><h5 id="0x00000007-KDC-Signatures"><a href="#0x00000007-KDC-Signatures" class="headerlink" title="0x00000007 KDC Signatures"></a>0x00000007 KDC Signatures</h5><p>由KDC用krbtgt hash签名，数字签名，防止PAC内容被篡改。是以krbtgt hash作为key的签名，以防止不受信任的服务伪造带有无效PAC的票证。</p><blockquote><p>上文提到“以***作为key”是因为在密码学中，生成摘要有两种方式：带key（即键控哈希）和不带key的。我们最熟悉的不带Key的hash算法就是MD5算法，相同的输入只会输出相同的信息摘要。但是在要求安全性比较高的地方就不能使用。例如在Kerberos中，PAC的两个数字签名都要求使用HMAC系列的带Key的校验和(sumcheck)算法，极大的提高了伪造PAC的难度。而在Kerberos中生成签名使用的Key就是Server hash和krbtgt hash，也就是说使用HMAC系列算法来进行消息认证既可以完成信息完整性认证，还能完成信源身份认证。</p><blockquote><p>关于HMAC：<a href="https://baike.baidu.com/item/hmac/7307543?fr=aladdin">https://baike.baidu.com/item/hmac/7307543?fr=aladdin</a></p></blockquote></blockquote><p>最后再放一张国外大佬做的图（walkerfuz也是搬运的他的），对应着上面讲的各个结构应该能看明白（一定要看），可以很明确的看出正常情况下TGT和PAC的包含关系。</p><p><img src="https://fishbed.easy233.top/14208234397566.png!small" alt="来自walkerfuz"></p><p>看不太明白的还有我做的简化版本</p><p><img src="https://fishbed.easy233.top/image-20201109210821664.png" alt="简化版本"></p><h4 id="PAC认证流程"><a href="#PAC认证流程" class="headerlink" title="PAC认证流程"></a>PAC认证流程</h4><p><img src="https://fishbed.easy233.top/image-20201109212134884.png" alt="流程图"></p><p>如果你看过上一篇文章的话，这个流程图你应该不会陌生。这个图和上一篇中相比，修改的地方就是TGT和Ticket包含的内容，在这张图这里我们加入了PAC。</p><p>把图翻译成中文就是，<strong>在微软版Kerberos实现中，KDC将PAC放在TGT中，TGT加密后从KDC_AS服务经Client-A中转给TGS服务，再放在由TGS服务返回的Ticket中，加密Ticket后经Client-A中转给Server-B</strong>。</p><p>不过要注意的是，TGT和Ticket中的PAC其实是不同的。</p><p>在<code>KRB_AS_REP</code>中PAC尾部的两个签名都是用krbtgt hash生成的，但是这两个签名内容以及签名的加密算法都是不一样的。因为在身份验证这个过程中，充当Client和KDC_TGS服务的可信第三方是KDC_AS服务，也就是说要请求的服务是KDC_TGS，所以server signature要用krbtgt hash生成。这点从上面的TGT结构图也能看出来。</p><p>而在<code>KRB_TGS_REP</code>里包含在Ticket中的PAC，则是在TGT中的PAC被KDC_TGS服务接受之后，KDC在验证过Client A的身份合法后会将PAC解密出来，然后验证尾部两个签名是否合法。如果验证通过KDC就认为PAC没有被篡改，然后将尾部的Server Signature更换为以Server hash作为key生成的签名。</p><p>而KDC Signature仍然使用krbtgt hash加密生成的签名（这一点我认为是walkerfuz在他的文章中写错了，他认为用的是Server_Sessionkey作为key进行的签名）</p><p><img src="https://fishbed.easy233.top/image-20201110174318715.png" alt="我认为是错误的地方"></p><p>因为虽然最后PAC被发送给了Server 但是Server并没有解析这个PAC，而是在验证了Server signature之后又把这个PAC发回了KDC，由KDC进行解析再将结果返回给Server。也就是说，虽然PAC被传递给了Client 和 Server，但是Client没有查看和修改PAC的能力，而Server虽然能查看PAC，但是它仍然不能修改PAC。</p><p>这一点在微软的官方文档中也写了出来：</p><p><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-apds/1d1f2b0c-8e8a-4d2a-8665-508d04976f84">文档</a></p><p><img src="https://fishbed.easy233.top/image-20201109213614132.png" alt="微软Docs"></p><blockquote><p>飞得更高（指炮塔）</p></blockquote><p>如果你懒得自己看英文的话你就注意看标签2的最开始部分：服务器会传递PAC给操作系统以得到一个Access token。然后服务器的操作系统又把PAC放在KERB_VERIFY_PAC请求中的AP-REQ（这不是KRB_AP_REQ，而是一个数据包中的字段）部分发送给域控（也就是KDC）。</p><blockquote><p>经过“松神”师傅师傅的讨论再引出一个细节。</p><p>实际上在AP-REQ中的PAC信息是“不完整的”，上图标签2后半句向我们说明了，在Server向操作系统传递了PAC之后，操作系统把PAC的签名（也就是两个校验和）放进了KERB_VERIFY_PAC中发送给了KDC。</p><blockquote><img src="https://fishbed.easy233.top/image-20211019181449033.png" alt="KERB_VERIFY_PAC结构体" style="zoom:80%;" /><p>从图中我们可以看到，其实这里面不存在PAC，只有两个校验和。和松神讨论认为是为了降低KDC的压力，同时避免造成浪费。（德国佬你学学人家）</p></blockquote></blockquote><p>Server在收到KDC返回的RPC状态码确认了Client之后才会向Client发送KRB_AP_REP，然后服务才会开始。</p><p>不过这也是我根据理论分析的结果，并没有自己实际抓包测试（因为平台有问题wireshark读取不到网络接口）。</p><h2 id="MS14-068"><a href="#MS14-068" class="headerlink" title="MS14-068"></a>MS14-068</h2><p>可算写到这个了，到这里都已经2200字了，Kerberos就™复杂的离谱（实际上把握住核心思想就不复杂）。</p><blockquote><p>注，MS14-068这一部分我是主要基于walkerfuz大佬的文章进行分析的，他的分析过程的确很精彩。你也可以认为我这部分是辅助理解大佬文章的文章。我在这里也只是写写我对那篇文章的理解（怎么可能）。</p></blockquote><p>原文链接：<a href="https://www.freebuf.com/vuls/56081.html">https://www.freebuf.com/vuls/56081.html</a></p><p>这个漏洞的出现原因是因为KDC采用了弱校验和算法，导致客户端有机会伪造高权限PAC加入TGT中。但我们回顾之前的流程，似乎也没有发现客户端有机会伪造PAC，我们来从流程慢慢分析来解决这个问题。</p><h3 id="暴论"><a href="#暴论" class="headerlink" title="暴论"></a>暴论</h3><p>在这里我直接提出一个暴论：MS14-068漏洞最核心的步骤是KRB_TGS_REQ。</p><p>暴论先放这里，我们先来了解一下Pykek这个知名MS14-068漏洞利用方法的攻击流程。</p><h3 id="图解Pykek流程"><a href="#图解Pykek流程" class="headerlink" title="图解Pykek流程"></a>图解Pykek流程</h3><p><img src="https://fishbed.easy233.top/image-20201112210231045.png" alt="总流程图"></p><p>可以看到和之前的图比起来很明显不对称，而且多了很多东西。</p><p>不过别担心，我们慢慢来分析这整个流程，本来也就不是几分钟内就能搞懂的东西。</p><p>看这个图你会发现我标出了不同颜色的线条。以下是解释</p><pre class="line-numbers language-none"><code class="language-none">橘色线条&#x3D;危险红色线条&#x3D;高危绿色线条&#x3D;大致正常<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那么让我们开始吧，不过正常的Kerberos我就不再讲解了，主要是说和MS14-068相关的部分。</p><h4 id="恶意KRB-AS-REQ"><a href="#恶意KRB-AS-REQ" class="headerlink" title="恶意KRB_AS_REQ"></a>恶意KRB_AS_REQ</h4><p><img src="https://fishbed.easy233.top/image-20201112212348881.png" alt="恶意KRB_AS_REQ"></p><p>你可以看到我把一个数据项标红了：include_pac:false</p><p>微软在Kerberos中加入了PAC之后，为了照顾一些域环境的特殊情况，微软的开发者又加入了一个选项：include_pac，通过控制这个选项我们可以指定这次身份验证是否需要PAC的参与，而MS14-068正是利用了这一点，整个攻击链就是从这里开始的。</p><p>下面是正常的KRB_AS_REQ</p><p><img src="https://fishbed.easy233.top/image-20201112213050672.png" alt="正常的KRB_AS_REQ"></p><p>通常情况下，KRB_AS_REQ请求中如果该标志被设置为true，那么只要接下来KDC_AS服务通过对Client A的身份认证，那么就会在返回的KRB_AS_REP数据包中的TGT里面加入PAC信息；对应的，如果被设置为false，那么TGT就不会包含PAC。这也是为了避免伪造PAC后数据包中有多个PAC导致失败。</p><p>一般来说，包含PAC信息的KRB_AS_REP数据包都会很大。</p><h4 id="KRB-AS-REP"><a href="#KRB-AS-REP" class="headerlink" title="KRB_AS_REP"></a>KRB_AS_REP</h4><p><img src="https://fishbed.easy233.top/image-20201113164334308.png" alt="没有PAC的KRB_AS_REP"></p><p>这一步没什么好说的，就是正常的KRB_AS_REP，而且KDC的确按照KRB_AS_REQ中的设置没有在TGT中添加PAC。</p><p>现在Client A就有了一个正常的不包含PAC的TGT了，可以用于之后的请求。</p><h4 id="恶意KRB-TGS-REQ（pykek方法）"><a href="#恶意KRB-TGS-REQ（pykek方法）" class="headerlink" title="恶意KRB_TGS_REQ（pykek方法）"></a>恶意KRB_TGS_REQ（pykek方法）</h4><p><img src="https://fishbed.easy233.top/image-20201113165249488.png" alt="恶意KRB_TGS_REQ"></p><p>这里就是MS14-068利用最关键的一步了。所以我们深入一点讲。</p><p>在讲这个恶意KRB_TGS_REQ之前，我们先来讲一下正常情况下的请求的结构是什么样子。不过这个图是我简化的版本，而且因为简化有些地方结构不太准确（讲内部结构的文章太少了，很多时候只能参考官网英文文档），只保留了和MS14-068相关的部分，实际上的请求包内容复杂得多，是一组很严密的结构。</p><p><img src="https://fishbed.easy233.top/image-20201113165637385.png" alt="正常的KRB_TGS_REQ"></p><h5 id="mgs-type"><a href="#mgs-type" class="headerlink" title="mgs-type"></a>mgs-type</h5><p>很简单，一个标识符，这里的内容表明了这是个什么请求。</p><h5 id="PA-DATA"><a href="#PA-DATA" class="headerlink" title="PA-DATA"></a>PA-DATA</h5><p>这里包含两个重要部分：include_pac标志和AP-REQ</p><p>但是要注意，这个AP-REQ可不是KRB_AP_REQ，而是发送给KDC包含着Client A所请求的Server B服务的信息。</p><h6 id="AP-REQ"><a href="#AP-REQ" class="headerlink" title="AP-REQ"></a>AP-REQ</h6><p>这里就是存放TGT的地方了，而TGT是用krbtgt hash加密的，所以Client无法查看PAC内容。而且就算拿到了krbtgt hash也不能修改PAC，因为有着两个校验和的存在。</p><p>但是话又说回来，既然都有了krbtgt hash那我们为什么不干脆伪造黄金票据呢（笑。 </p><h5 id="REQ-BODY"><a href="#REQ-BODY" class="headerlink" title="REQ-BODY"></a>REQ-BODY</h5><h6 id="Sname"><a href="#Sname" class="headerlink" title="Sname"></a>Sname</h6><p>这个是要请求的服务，TGS_REP获得的ticket是用该服务用户的hash进行加密的。</p><p>有个比较有意思的特性是，如果指定的服务是krbtgt，那么拿到的TGS票据（Ticket）是可以当做TGT用的。因为TGT只是一种特殊类型的Ticket，两者在数据结构上没有什么太大的不同。</p><h6 id="enc-authorization-data（可选项）"><a href="#enc-authorization-data（可选项）" class="headerlink" title="enc-authorization-data（可选项）"></a>enc-authorization-data（可选项）</h6><p>内部是用密钥加密的信息，一般是用子会话密钥（sub-sessionkey）加密的，而sub-sessionkey存在于PA-DATA字段下AP-REQ中的Authenticator字段。也可以直接用SessionKey加密。这个信息只会存在于KRB_TGS_REQ请求中。</p><blockquote><p>不知道我理解的对不对，原文来自于RFC1510（当然RFC4120里面也有），巨离谱，是一份1993年的112页全英文文档，我人都傻了</p><blockquote><p>关于sub-SessionKey的解释我在RFC4120文档中找到了</p><blockquote><p>Sub-session key<br>A temporary encryption key used between two principals, selected and exchanged by the principals using the session key, and with a lifetime limited to the duration of a single association.  The sub-session key is also referred to as the subkey.<br>翻译下来大致是这样：<br>子会话密钥<br>在两个主体之间使用的临时加密密钥，由主体使用会话密钥进行选择和交换，并且其生存期仅限于单个关联的持续时间。子会话密钥也称为子密钥。</p></blockquote><p>sub-session key可以由Client指定。</p><p>想了解更多建议查看文档原文</p><p>RFC4120：<a href="https://datatracker.ietf.org/doc/rfc4120/?include_text=1">https://datatracker.ietf.org/doc/rfc4120/?include_text=1</a></p><p>RFC1510：<a href="https://tools.ietf.org/html/rfc1510">https://tools.ietf.org/html/rfc1510</a></p></blockquote></blockquote><p>在了解完正常的KRB_TGS_REQ之后我们就可以研究Pykek到底是怎么构建一个恶意请求的了。</p><p><img src="https://fishbed.easy233.top/image-20201124161755862.png" alt="恶意请求"></p><p>首先，我们来确定一下我们手头有什么材料：</p><ul><li>一个没有PAC信息的正常TGT</li><li>可以伪造的高权限PAC。</li></ul><p>还有KDC的特性：</p><ul><li>可以操作的include-pac标识；</li><li>可以用于单次会话可由Client发送的临时加密密钥subkey；</li><li>可以用subkey将信息加密放在enc-authorization-data中</li><li>如果指定的服务是krbtgt，那么拿到的TGS票据（Ticket）是可以当做TGT用的。</li></ul><p>似乎我们已经有了进行攻击所需的全部资源。</p><p>但是，这些还不够，我们还面临几个问题：</p><ol><li>虽然我们有正常TGT，但是我们没有krbtgt hash，无法将伪造的高权限PAC放进去。</li><li>include-pac标识虽然可以操控，但是似乎也没什么可利用的点。</li><li>Kerberos要求PAC必须有服务器校验和以及KDC校验和，而且都需要有Key参与，也就是从理论上来说哪怕我们能伪造PAC权限信息也不能伪造签名，那™不是白忙活。</li></ol><p>这波咋办嘞？分析了半天什么操作都打出来了，难道要在最后一波团灭？</p><p>幸好，出于一些未知的原因，对手开始犯蠢主动配合我们操作了。</p><p>对于前两个问题，如果我们将PAC用自己生成的subkey加密放在KRB_TGS_REQ中的enc-authorization-data字段，然后再用SessionKey将subkey加密放在authenticator中。那么KDC就会配合我们，用SessionKey解密出subkey再解密出我们生成的高权限PAC信息并且成功解析。</p><p>对于第三个最要命的问题，KDC的行为更离谱，Kerberos要求两个签名都必须有Key参与，但是微软的实现却使得可以使用任意算法来进行签名，而且算法也是由Client指定的。</p><p><img src="https://fishbed.easy233.top/QQ%E5%9B%BE%E7%89%8720201127211846.jpg" alt="WTF？？？"></p><p>也就是说我们可以用MD5算法来对PAC进行签名，只要我们不改变PAC的信息，那么签名就肯定会通过KDC的验证，毕竟这里的签名已经失去了对信源身份认证的效果。而这点也就是MS14-068漏洞的核心：“微软Kerberos实现支持弱哈希机制，导致其可以用于伪造信息”。微软的修复补丁也是添加了对签名算法类型的校验。</p><blockquote><p>实际上在我搜到的国外博客中，有一篇提到“MS14-068其实是MS11-013在不同代码区域中的重复，…………，而且鉴于在补丁发布之前，漏洞已经被积极利用，所以其实MS14-068可能已经被高级攻击者使用了很长一段时间了。“也就是说MS14-068哪怕是在14年，也是被人玩剩下的东西了，在漏洞挖掘这条路上我们还有很长距离要走。</p></blockquote><p>经过上面两波迷惑操作之后，攻击者就成功的把伪造的高权限PAC和TGT给发送给KDC_TGS服务了，而且KDC在检查过之后发现“并没有什么问题”，然后就开始准备回复了。</p><p>但似乎还有一个不太对的地方，不过我们放到下一部分来说。</p><h4 id="畸形KRB-TGS-REP"><a href="#畸形KRB-TGS-REP" class="headerlink" title="畸形KRB_TGS_REP"></a>畸形KRB_TGS_REP</h4><p>我们之前在介绍PAC的时候讲过，KDC在验证完Server signature和KDC signature之后会在更换这两个签名。对于Server signature，KDC用接收到的REQ数据包中Sname字段指定的服务的账户hash进行签名；而KDC signature就还是krbtgt hash。</p><p>而我们发送的恶意TGS_REQ请求中，Sname字段指定的服务却是krbtgt（和AS_REQ指定的服务一致），也就是说KDC这次会用krbtgt hash进行Server signature的签名。（有没有感到似乎抓到了什么头绪？）</p><p>我们先把PAC暂时放一放，看看别的东西。</p><p>还记得正常的KRB_TGS_REP会发送什么给Client吗？</p><p>KDC会发送Ticket和{Server_SessionKey}SessionKey。</p><p>但是，我们在发送恶意TGS_REQ请求时，虽然信息标识为TGS_REQ，但是服务请求对象（Sname）却是krbtgt，也就是说之前的TGS_REQ请求其实可以看做是套着TGS_REQ皮的AS_REQ请求。</p><p>而KDC看到Sname为krbtgt后就会用krbtgt hash来加密“Ticket”（是不是又察觉了什么？）。而后，KDC又用subkey加密了SessionKey，最后和“Ticket”一起发送给了Client。但这个回复其实是个”缝合怪“。我们用公式来表示一下这个回复。</p><p><code>畸形KRB_TGS_REP=“Ticket”，&#123;SessionKey&#125;subkey</code></p><p>而<code>&quot;Ticket&quot;=&#123;SessionKey,Client A信息，正确签名的高权限PAC&#125;krbtgt hash</code></p><p>看起来和AS_REP真的是一毛一样（区别肯定还是有的）！</p><p><img src="https://fishbed.easy233.top/image-20201128203300542.png" alt="正常的AS_REP"></p><p>也就是说，在KDC在TGS_REP中回复给了Client一个TGT，而不是一个Ticket，虽然两者的相似之处可能有99%，但就是那1%的不同决定了它们的真实属性（听起来有点像人与猿）。</p><p>现在，攻击者就拿到了实施攻击的所有资源：</p><ul><li>一个包含着高权限PAC的TGT</li><li>用于和KDC通讯的SessionKey</li></ul><p>那接下来就是整活儿时间了。</p><h4 id="整活儿"><a href="#整活儿" class="headerlink" title="整活儿"></a>整活儿</h4><p>其实接下来的发生的事情就和一个高权限用户的正常访问近似。还是老样子，KRB_TGS_REQ-》KRB_TGS_REP-》KRB_AS_REQ-》KRB_AS_REP。然后服务开始，攻击者该干啥干啥，需要访问下一个服务的话就再走一遍攻击流程，获得下一张Ticket。后续的更具体的攻击手法也就不在这篇文章的讨论范围了。</p><h3 id="关于我为什么不认为MS14-068是微软的阴谋"><a href="#关于我为什么不认为MS14-068是微软的阴谋" class="headerlink" title="关于我为什么不认为MS14-068是微软的阴谋"></a>关于我为什么不认为MS14-068是微软的阴谋</h3><p>可能国内现在的信息安全学习者对于MS14-068这个漏洞的内部原理理解大都来自于walkerfuz在freebuf上发表的文章，文章的标题就是<a href="https://www.freebuf.com/vuls/56081.html">《深入解读MS14-068漏洞：微软精心策划的后门？》</a>，老实说，我一开始学习的时候也被这个阴谋论唬住了，跟着他的文章一步一步分析下去，似乎也就是有些阴谋论的样子，毕竟这个漏洞的确有很多“巧合”。</p><p>但是随着我一步一步挖掘细节，去参考官方文档和国外的一些安全博客进行学习，我发现这个阴谋论似乎逐渐被推翻了。</p><p>因为我发现，walkerfuz在他文章中列举的三个“巧妙”的错误，其实内部都是有合理的逻辑的。</p><p><img src="https://fishbed.easy233.top/image-20201202161910781.png" alt="三个“巧妙”的错误"></p><p>我就按照他说的错误来一步一步证明我的观点：</p><ol><li>关于可以由Client指定签名算法，实际上来说，Client根本就没有指定签名算法。因为从根本上来讲，正常情况下PAC都是由KDC生成的，何来Client指定签名算法一说。KDC从来不相信别的主体，它只相信自己以及只能由自己发送的数据。MS14-068中，所谓攻击者指定了PAC签名算法，实际上只是KDC相信了这个伪造的PAC是自己发送的，况且，本身PAC的设计规范就是要求必须要声明签名算法类型的。</li><li>关于KDC可以解析放在请求包中其它地方的PAC。对于这点，我猜测可能是微软在数据包解析时没有检查PAC数据的来源，而是在数据包中解析到了PAC之后就验证PAC的签名，哪怕这个PAC并没有在TGT中。而微软这么实现的理由可能是因为过于信任PAC的签名机制，毕竟正常情况下就算伪造的高权限PAC被解析，也会因为签名校验无法通过而导致攻击失败；当然也可能只是单纯因为KDC在接收到包文之后直接各项提取出来然后分发给各个信息处理单元该干嘛干嘛，程序这样实现也是很正常的。而“放在其它地方”，这个其它地方也是很有讲究的，利用的也是Kerberos的正常机制，Kerberos允许在一个请求会话中包含一个子会话，而子会话的内容就由子会话密钥（subkey）加密之后放在REQ-BODY中的enc-authorization-data字段，MS14-068正是利用了这一点。</li><li>KDC从authenticator中提取出subkey来解密出PAC也是很正常的，符合子会话要求。至于重新采用自身的krbtgt hash分别作为key生成Server signature和KDC signature是因为在恶意KRB_TGS_REQ请求中，指定了Sname字段内容为krbtgt。至于再用subkey加密SessionKey，同新生成的TGT一起发送回Client，应该和Kerberos内部关于子会话的机制有关，但是这个信息太少，也只是我的猜测。</li></ol><p>总结一下，MS14-068正是攻击者利用微软对于PAC签名实现允许弱哈希校验这个错误，配合上Kerberos自身的一些称不上漏洞的机制，组合而成的一个漏洞。是特意设计的“后门”的概率不大，如果它是阴谋，我们也可以思考一下，这个漏洞会不会对西方的企业产生危害，很明显，它会，所以阴谋论根本上就不太站得住脚。不过，就算它不是后门，我们仍然要警惕，在一些涉及到国家安全的领域，一定要用我们自己的东西，哪怕它也存在一些漏洞，也比直接被用预留后门轻轻松松攻破要好。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><h3 id="总体学习："><a href="#总体学习：" class="headerlink" title="总体学习："></a>总体学习：</h3><ul><li><a href="https://www.freebuf.com/articles/system/45631.html">https://www.freebuf.com/articles/system/45631.html</a></li><li><a href="https://www.secpulse.com/archives/94848.html">https://www.secpulse.com/archives/94848.html</a></li><li><a href="https://labs.f-secure.com/archive/digging-into-ms14-068-exploitation-and-defence/">https://labs.f-secure.com/archive/digging-into-ms14-068-exploitation-and-defence/</a></li></ul><h3 id="KRB请求细节："><a href="#KRB请求细节：" class="headerlink" title="KRB请求细节："></a>KRB请求细节：</h3><ul><li><a href="https://daiker.gitbook.io/windows-protocol/">https://daiker.gitbook.io/windows-protocol/</a></li></ul><h3 id="MS14-068："><a href="#MS14-068：" class="headerlink" title="MS14-068："></a>MS14-068：</h3><ul><li><a href="https://www.freebuf.com/vuls/56081.html">https://www.freebuf.com/vuls/56081.html</a></li><li><a href="https://labs.f-secure.com/archive/digging-into-ms14-068-exploitation-and-defence/">https://labs.f-secure.com/archive/digging-into-ms14-068-exploitation-and-defence/</a></li></ul><h3 id="密码学部分："><a href="#密码学部分：" class="headerlink" title="密码学部分："></a>密码学部分：</h3><ul><li><a href="https://www.cnblogs.com/ainingxiaoguai/p/13175975.html">https://www.cnblogs.com/ainingxiaoguai/p/13175975.html</a></li><li><a href="http://www.kokojia.com/article/25657.html">http://www.kokojia.com/article/25657.html</a></li><li><a href="https://xz.aliyun.com/t/1943">https://xz.aliyun.com/t/1943</a></li></ul><h3 id="官方文档："><a href="#官方文档：" class="headerlink" title="官方文档："></a>官方文档：</h3><ul><li>RFC4120：<a href="https://datatracker.ietf.org/doc/rfc4120/?include_text=1">https://datatracker.ietf.org/doc/rfc4120/?include_text=1</a></li><li><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/166d8064-c863-41e1-9c23-edaaa5f36962">[MS-PAC]</a></li><li>[MS-KILE]：[<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/e720dd17-0703-4ce4-ab66-7ccf2d72c579">MS-KILE]: Glossary | Microsoft Docs</a></li><li>[MS-APDS]：[<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-apds/1d1f2b0c-8e8a-4d2a-8665-508d04976f84">MS-APDS]: Kerberos PAC Validation | Microsoft Docs</a></li></ul><h3 id="鸣谢："><a href="#鸣谢：" class="headerlink" title="鸣谢："></a>鸣谢：</h3><p>松神</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>写这篇文章真的花了巨久，前前后后自闭，查博客，查官方文档，复习了一遍密码学基本概念，大半个月才结束，写了接近6000字，加上之前的文章已经写超过万字了。</p><p>想写出一篇好博客真的是很艰苦的一件事情（虽然我也不知道我这篇能不能被称之为好，但我觉得应该可以），要在别人研究过的东西中提取出自己的思想，拿出自己的见解。可能做研究就是这样的吧，虽说文章标题是“非硬核向”，但回过头自己读着看看，似乎完全是把人骗进来杀，干脆改成自闭向好了XD。</p><p>现在真的是感觉如释重负，可算把这么个东西码完了，之后会再慢慢修改的。如果你在学习的过程中发现了什么问题也欢迎通过邮箱或QQ联系我，当然，用GitHub直接在我的仓库下提issue也是可以的。</p><p>以上。</p><hr><p>2021-10-19 修改</p><p>修改了文中PAC流程部分对与最后一步认证的详细过程分析，感谢松神的热心交流。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kerberos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一张图带你了解Kerberos认证流程</title>
      <link href="/posts/42406.html"/>
      <url>/posts/42406.html</url>
      
        <content type="html"><![CDATA[<p>设想一下，如果世界上只有A和B知道A的密码，他们该如何用这个密码来证明自己的身份？</p><p>在现实中我们有很多办法，但是在充满了未知和陷阱的赛博空间中很多办法是统统不能用的。因为如果一方是假的，那么A的密码就失窃了。那么如果我们要做到既不说出密码，又得让对方知道自己有这个密码，该怎么办呢？</p><p>Kerberos为我们提供了一套严密的办法。</p><h2 id="Kerberos简介"><a href="#Kerberos简介" class="headerlink" title="Kerberos简介"></a>Kerberos简介</h2><p>Kerberos 是Windows活动目录中使用的客户/服务器认证协议，为通信双方提供双向身份认证。</p><p>其设计目标是通过密钥系统为客户机/服务器应用程序提供强大的认证服务。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并<strong>假定网络上传送的数据包可以被任意地读取、修改和插入数据</strong>。</p><h2 id="名词解释（建议全文背诵，XD）"><a href="#名词解释（建议全文背诵，XD）" class="headerlink" title="名词解释（建议全文背诵，XD）"></a>名词解释（建议全文背诵，XD）</h2><ul><li><p>KDC</p><p>Kerberos认证由三方参加：客户端，服务端（或者称为资源）和权威第三方认证。参与的权威第三方认证被称为密钥分发中心（简称KDC，KeyDistribution Center）。</p><p>KDC有两个服务及一个数据库组成：</p></li></ul><p><img src="https://fishbed.easy233.top/image-20201030181111595.png" alt="KDC组成"></p><pre class="line-numbers language-none"><code class="language-none">1. 身份验证服务（Authentication Server，简称AS）2. 票据授予服务（Ticket Granting Server，简称TGS）3. AD（account database）账户数据库，在这里面保存了域中所有客户端和服务器的账户信息，而且是以白名单的方式进行工作的。也就是说只有经过认证的在域控注册的账户才能正常在域中进行访问。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    在之后这两个服务分别称为<code>KDC_AS</code>和<code>KDC_TGS</code>。</p><p>​    在Windows域环境下，身份验证服务和票据授予服务可同时运行在任何可写的域控服务器上。</p><p>​    也就是说从物理层面来看DC（域控）≈KDC（密钥分发中心）。</p><ul><li><p>Ticket</p><p>在Kerberos认证中，客户端向服务端认证的凭据叫做<code>票据（Ticket）</code>；</p></li><li><p>TGT</p><p>用于向KDC_TGS申请票据的临时证明叫做<code>TGT（Ticket Granting Ticket）</code>，直译过来就是（用于）票据授予的票据。（一听就是老套娃了）TGT是一种特殊类型的Ticket，可用于获取其他Ticket。 TGT是在Client与身份验证服务（AS）的初始身份验证之后获得的； 此后，用户无需出示其凭据，而可以使用TGT获得后续票证。</p></li><li><p>SessionKey</p><p>会话密钥，用于Client和KDC通讯的密钥，由KDC_AS服务生成，生存期为整个“会话”。</p></li><li><p>Server_sessionKey</p><p>服务会话密钥，用于Client和Server通讯的密钥，由KDC_TGS服务生成。</p></li></ul><h2 id="总流程图"><a href="#总流程图" class="headerlink" title="总流程图"></a>总流程图</h2><p><img src="https://fishbed.easy233.top/Client%20A_PS.png" alt="Kerberos流程"></p><h2 id="域认证粗略流程"><a href="#域认证粗略流程" class="headerlink" title="域认证粗略流程"></a>域认证粗略流程</h2><h3 id="1-第一步"><a href="#1-第一步" class="headerlink" title="1. 第一步"></a>1. 第一步</h3><p>客户端向KDC_AS服务请求(也就是KRB_AS_REQ)，希望验证自己的身份获取TGT。KDC得到了这个消息，首先得判断客户端是否是可信赖的，也就是所谓的白名单黑名单。这就是KDC_AS服务完成的工作，通过在AD中存储的黑名单和白名单来区分合法客户端。成功后，返回加密的SessionKey和TGT给客户端（KRB_AS_REP)。</p><h3 id="2-第二步"><a href="#2-第二步" class="headerlink" title="2. 第二步"></a>2. 第二步</h3><p>客户端得到了TGT后，继续向KDC_TGS请求（KRB_TGS_REQ)，希望获取访问某个资源的权限。KDC又得到了这个消息，这时候通过客户端发来消息中的TGT，判断出了客户拥有了这个权限，给了客户访问资源的Ticket票据(KRB_TGS_REP)。</p><h3 id="3-第三步"><a href="#3-第三步" class="headerlink" title="3. 第三步"></a>3. 第三步</h3><p>客户得到Ticket票据后，终于可以成功访问资源。但是注意，这个Ticket票据只是针对这个资源，其他资源仍旧需要向KDC_TGS申请。  </p><h2 id="域认证详细流程"><a href="#域认证详细流程" class="headerlink" title="域认证详细流程"></a>域认证详细流程</h2><h3 id="1-KRB-AS-REQ"><a href="#1-KRB-AS-REQ" class="headerlink" title="1.KRB_AS_REQ"></a>1.KRB_AS_REQ</h3><img src="https://fishbed.easy233.top/image-20201030190626242.png" alt="KRB_AS_REQ" style="zoom: 67%;" /><p>正如你在这张图中看到的，在认证流程中Client A向<code>KDC_AS</code>发送了<code>KRB_AS_REQ</code>请求（身份认证请求）。</p><p>在这个请求中，Client A向KDC_AS发送了用自己的密码NTML hash（以后就简称为Client A hash）作为密钥加密的一个时间戳，以及明文传输的Client A信息（一般为用户名）和一串随机字符串。</p><blockquote><p>NTLM Hash与NTLM<br>在Windows中，密码Hash目前称之为NTLM Hash，其中NTLM全称是：“NT LAN Manager”。</p><p>这个NTLM是一种网络认证协议，与NTLM Hash的关系就是：NTLM网络认证协议是以NTLM Hash作为根本凭证进行认证的协议。</p><p>也就是说，NTLM与NTLM Hash相互对应。</p><p>NTLM Hash的产生<br>假设我的密码是admin，那么操作系统会将admin转换为十六进制，经过Unicode转换后，再调用MD4加密算法加密，这个加密结果的十六进制就是NTLM Hash</p><p>admin -&gt; hex(16进制编码) = 61646d696e<br>61646d696e -&gt; Unicode = 610064006d0069006e00<br>610064006d0069006e00 -&gt; MD4 = 209c6174da490caeb422f3fa5a7ae634</p><p>引用自：<a href="https://www.secpulse.com/archives/94848.html">https://www.secpulse.com/archives/94848.html</a></p></blockquote><p>当KDC_AS接收到KRB_AS_REQ请求之后会发生这些事：</p><ul><li><p>首先AS会看到Client A的用户名，于是AS在AD中查找Client A的NTLM hash。</p></li><li><p>AS用查找出的Client A hash解密<code>&#123;时间戳&#125;Client A hash</code>，得到时间戳。</p><p>因为AS可以用AD中查找出的Client A hash来解密<code>&#123;时间戳&#125;Client A hash</code>，那么AS就可以确认Client A的身份了，因为理论上来说别的账号是没有Client A的密码的。</p></li><li><p>AS还看到了一串随机字符串</p></li></ul><blockquote><p>在这里我们先了解一下为什么Client A要加密一串时间戳而不是别的什么玩意儿。</p><p>就像我在前面说的，Kerberos的设计背景之一就是“假定网络上传送的数据包可以被任意地读取、修改和插入数据”。</p><p>为了保证安全，避免黑客在网络中截获KRB_AS_REQ，然后伪装成Client A欺骗KDC（我们把这种攻击手段称为“重放攻击”）。因为重放攻击伪装也需要消耗一定时间，所以KDC在收到请求后把解密得到的时间戳和当前时间来进行对比，如果相差过大的话就可以判断为重放攻击。</p><p>这也是为什么我们需要保证Windows域中所有设备的时间同步的原因。</p><p>所以，如果不是加密时间戳而是别的东西的话，就没办法避开重放攻击了。</p></blockquote><h3 id="2-KRB-AS-REP"><a href="#2-KRB-AS-REP" class="headerlink" title="2. KRB_AS_REP"></a>2. KRB_AS_REP</h3><p><img src="https://fishbed.easy233.top/image-20201030195439208.png" alt="KRB_AS_REP"></p><p>在上一步AS_REQ中，KDC_AS已经认证了Client A 的身份，现在到KDC向Client A证明自己并且向Client A发送之后服务所需材料的时候了。</p><p>KRB_AS向Client A发送了KRB_AS_REP，在这里面包含了两个信息：</p><ul><li><p>TGT（忘了这是什么的上去翻名词解释），TGT={Client A信息，SessionKey}krbtgt hash</p><blockquote><p>krbtgt是Windows域中KDC的一个特殊用户，你可以理解为KDC的账户就是krbtgt</p></blockquote></li><li><p>{SessionKey，时间戳，随机字符串}Client A hash</p><blockquote><p>SessionKey在总流程图中有解释</p></blockquote></li></ul><p>那么KDC如何向Client A证明自己的身份呢？</p><p>这时候上文我们提到的随机字符串就派上用场了。因为这串随机字符串是当初Client A生成并发送的，那么理论上来说，如果Client A用自己的密码hash从返回的数据包中解密得到这么一个随机字符串，Client A就完成了对KDC身份的认证。因为别的设备不会有这串随机字符串，更不可能用Client A hash来加密<code>&#123;SessionKey，时间戳，随机字符串&#125;Client A hash</code>。</p><p>说到现在我们还没提到SessionKey这个东西，我们回顾上面的过程，似乎不需要SessionKey就已经完成了Client A和KDC的相互认证。但是SessionKey真的是多余的吗？</p><p>很明显不是的，因为程序员不会在数据包中放一串无用信息来占空间。不过这个不是真正的原因。</p><p>真正的原因是因为，如果Client每次认证都需要让KDC调出账号密码，进行hash加解密还有各种操作，那么KDC将会非常忙碌。而且域中肯定不会只有一个Client，而且每个Client可能每天要验证数十次。</p><p>这活儿如果要一个人去做你还不如干脆sa了他，对于KDC来说也是很难负担得起的。所以Kerberos设计了一个巧妙的办法来解决KDC的这一部分压力问题。</p><blockquote><p>KDC生成了两把一样的密钥SessionKey（为什么叫SessionKey看上面的总流程图，有解释），作为之后Client A和KDC之间互相认证用。因为如果KDC在Client A发来的请求中提取到了这个SessionKey，那么就能证明Client A的身份，免去了从AD中调出Client A的密码以及进行hash加解密的工作。</p><p>按照常理来说，这两把密钥中应该有一把保留在KDC，就像是宿舍的锁总是要有一把钥匙在宿管一样。但是对于KDC来说保留这个密钥也是一个负担，于是KDC将这个应该留下的密钥委托给Client A保管。之后如果Client A需要和KDC验证身份的时候只需要交还这把密钥就行了。</p><p>这个办法乍一听不太靠谱，因为Client A可能被假冒，如果假冒的Client A交还回来一把假密钥怎么办呢？</p><p>为了避免这个问题，KDC将这个SessionKey用自己的密码hash（也就是krbtgt hash）加密，然后委托给A。这个委托给A的密钥在Kerberos中就叫做TGT。因为Client A没有krbtgt hash，所以也就无从伪造SessionKey。</p><blockquote><p>当然，如果有的话那么就可以伪造黄金票据了，这是后话暂且不表。</p></blockquote><p><code>TGT=&#123;Client A信息，SessionKey&#125;krbtgt hash</code></p><p>有了这个委托保存机制之后，KDC只需要有自己的krbtgt hash，就能够解开委托给所有Client的TGT，从而获取与这个Client进行身份验证的密钥。从而减轻了KDC的工作负担。</p></blockquote><p>Client A在收到KRB_AS_REP之后，用自己的Client A hash解密<code>&#123;SessionKey，时间戳，随机字符串&#125;Client A hash</code>。通过解密提取出的时间戳和随机字符串来确定KDC的可信任，然后把SessionKey和TGT保留下来之后供接下来的认证使用。</p><h3 id="3-KRB-TGS-REQ"><a href="#3-KRB-TGS-REQ" class="headerlink" title="3.KRB_TGS_REQ"></a>3.KRB_TGS_REQ</h3><p><img src="https://fishbed.easy233.top/image-20201102145156077.png" alt="KRB_TGS_REQ"></p><p>在经过了与KDC_AS的身份认证之后，Client A拿到了TGT，下一步就是向KDC_TGS申请票据（Ticket）了。</p><p>首先，肯定不用说，TGT是要发送给KDC_TGS的（这也就是为什么TGT是票据授予票据）。</p><p>然后就是用在KRB_AS_REP中获取到的SessionKey加密{Client A信息，时间戳}，以及要访问的Server B的相关信息。</p><p>也就是说</p><pre class="line-numbers language-none"><code class="language-none">KRB_TGS_REQ&#x3D;TGT，&#123;Client A信息，时间戳&#125;SessionKey+“Server B服务相关信息”<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当KDC接收到KRB_TGS_REQ之后，首先会使用krbtgt hash解密TGT，从中提取出Client A信息和SessionKey；再用SessionKey来解密出Client A信息，时间戳。通过提取出的两个Client A信息进行比较来确定Client A的信息是否正确，时间戳避免重放攻击。</p><blockquote><p>虽然表面上这两个Client A信息都是由Client A发送的，但实际上TGT中的Client A信息是KDC自己从数据库中查询出来的，所以只要对比信息是否吻合就可以确定Client A身份是否合法</p></blockquote><h3 id="4-KRB-TGS-REP"><a href="#4-KRB-TGS-REP" class="headerlink" title="4. KRB_TGS_REP"></a>4. KRB_TGS_REP</h3><p><img src="https://fishbed.easy233.top/image-20201102194121168.png" alt="KRB_TGS_REP"></p><p>一旦KDC通过了Client A的身份验证，那么KDC就要帮助Client A和Server B相互认证了。</p><p>在这一步就类似于之前KDC生成SessionKey以便于Client A和KDC_TGS通信一样，KDC_TGS生成了一对新的密钥，这里我们把它叫做<code>Server_SessionKey</code>。而且这两把密钥同样是用不同的hash加密后都委托给Client A的。</p><p>KDC_TGS向Client A发送了一个数据包里面包含了如下两条信息：</p><ul><li>票据（Ticket）={Server_SessionKey，Client A信息}Server B hash</li></ul><p>KDC把其中的一把Server_SessionKey和Client A信息一起用Server B hash加密之后，形成了一个只有Server B能加密的Ticket。</p><blockquote><p>我们不难发现对于Client A来说，不管是TGT还是Ticket都不是他能解密的。二者还都包含了Client A的信息和一把用于下一次通信的，只有服务提供方能解密的密钥，同时也都有着验证服务请求方身份的功能（验证身份这个后文再说）。</p><blockquote><p>还有一点就是票据中的Client A信息可不单单是一些简单的基本信息，这里面包含了Client A所在的Domain Groups（域组），如果Client A属于很多个组，那么TGS_REP包会非常大。</p></blockquote></blockquote><ul><li>{Server_SessionKey}SessionKey</li></ul><blockquote><p>这里又像之前一样出现了一层套娃，用SessionKey加密的Server_SessionKey。</p></blockquote><p>Client A接收到了<code>Ticket</code>和<code>&#123;Server_SessionKey&#125;SessionKey</code>之后，先用自己手里的SessionKey解密拿到Server_SessionKey。对于Ticket没有办法，因为Client A并没有Server B hash，只能在向Server B请求时发给Server B。</p><blockquote><p>如果一个攻击者拿到了Server B hash，那么他将可以伪造白银票据，这也是后话，暂且不表。</p></blockquote><h3 id="5-KRB-AP-REQ和KRB-AP-REP"><a href="#5-KRB-AP-REQ和KRB-AP-REP" class="headerlink" title="5. KRB_AP_REQ和KRB_AP_REP"></a>5. KRB_AP_REQ和KRB_AP_REP</h3><p><img src="https://fishbed.easy233.top/image-20201102203522367.png" alt="KRB_AP_REQ和KRB_AP_REP"></p><p><del>因为这两个包涉及到的东西都比较简单，所以就放一起说了。不是因为我偷懒</del></p><p>现在Client A有了Server_SessionKey和Ticket，那就已经万事具备了。</p><p>Client A给Server B发送了<code>KRB_AP_REQ</code>，它由两个部分组成：</p><ul><li>{Client A信息，时间戳}Server_SessionKey</li><li>Ticket={Server_SessionKey，Client A信息}Server B hash</li></ul><p>Server B在收到KRB_AP_REQ之后用自己的Server B hash解密Ticket，从中拿到了Server_SessionKey和KDC发送的Client A信息；</p><p>再用这把Server_SessionKey解密{Client A信息，时间戳}Server_SessionKey，提取到Client A信息和时间戳。</p><p>Server B对比两个收到的Client A信息确定A的身份和权限（听着是不是很熟悉？KDC_TGS也是这么做的，只不过TGS是查询的权限）。</p><p>如果验证通过那么Server B就相信Client A身份是真的。</p><blockquote><p>也就是说Server B对于Client A的认识全是基于KDC的，如果Krbtgt hash被泄露之后，那么整个域的信任关系就不复存在了。可信第三方已经不值得相信了，这波叫敌在本能寺！</p></blockquote><p>时间戳作用和以前一样，都是防重放攻击的。</p><hr><p><img src="https://fishbed.easy233.top/image-20201102203522367.png" alt="KRB_AP_REQ和KRB_AP_REP"></p><p>Server B确定了Client A可信而且拥有申请对应服务的权限之后就要着手于给Client A提供服务了，当然，Server B同样需要向Client A证明自己的身份。</p><p>于是Server B向Client A发送了<code>KRB_AP_REP</code></p><p>这个很简单</p><pre class="line-numbers language-none"><code class="language-none">AP_REP&#x3D;&#123;时间戳&#125;Server_SessionKey<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不过，为什么Client A看到这么简单一个回复就能证明Server B是可信的呢？</p><p>因为Server_SessionKey是包含在Ticket中的，而Ticket又是由Server B hash加密的。也就是说只有真正的Server B才能返回这个Server_SessionKey。如果返回的Server_SessionKey不对的话，Client A也就能判明返回这个数据包的Server B是假冒的。</p><p>Client A用Server_SessionKey解密拿到时间戳，确定不是重放攻击，那么认证过程就结束了。</p><p>至此所有的认证过程结束，剩下的服务就交给别的协议执行吧，Kerberos不管这个。</p><blockquote><p>实际上如果我们直接在网络中抓包会发现其实并没有直接看到KRB_AP_REP和KRB_AP_REQ。这是因为Kerberos是身份认证协议，往往是其它服务协议的前提，所以说你可能会在这些服务协议的第一个请求包里找到KRB_AP_REQ，在返回包里找到KRB_AP_REP。</p></blockquote><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>这篇文章是我在学习域渗透相关知识的关于Kerberos的总结文章，算了算从开始到现在花去了半个月的时间，一开始在网上找了各种资料，但是看着都很让人自闭，决定要写一篇相对全面（？）而且更加易懂（？？？）的讲Kerberos的文章。</p><p>不过还是我实力⑧行，肯定还有很多东西没讲到，有的地方应该还会有错误。如果你们在阅读过程中发现了什么错误欢迎联系我指出。</p><p>我的邮箱是：<a href="mailto:&#x38;&#x39;&#x32;&#x31;&#55;&#53;&#x37;&#51;&#x36;&#64;&#113;&#113;&#46;&#99;&#111;&#x6d;">&#x38;&#x39;&#x32;&#x31;&#55;&#53;&#x37;&#51;&#x36;&#64;&#113;&#113;&#46;&#99;&#111;&#x6d;</a></p><p>非常感谢。</p><p><del>结果写文章还是把自己写自闭了。全篇下来接近5000字，也才只是讲了一下Kerberos的流程，剩下的里面一些过程漏洞的利用还没讲。只有等下篇文章了，我现在除了肚子饿就是想开着OF40去雷普锅盖头。</del></p><p>告辞。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Wireshark网络分析就是这么简单》——林沛满</p><p><a href="https://www.secpulse.com/archives/94848.html">https://www.secpulse.com/archives/94848.html</a></p><p><a href="https://www.freebuf.com/vuls/56081.html">https://www.freebuf.com/vuls/56081.html</a></p><p><a href="https://www.freebuf.com/articles/system/45631.html">https://www.freebuf.com/articles/system/45631.html</a></p><p><a href="https://www.cnblogs.com/tonny-li/p/5466092.html">https://www.cnblogs.com/tonny-li/p/5466092.html</a> （这篇写的很好，但是对于英语不好的你可能进去就感觉自己被雷普了）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kerberos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特工A和特工B的故事—_Kerberos</title>
      <link href="/posts/48427.html"/>
      <url>/posts/48427.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://fishbed.easy233.top/MI6.jpeg" alt="MI6"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们可以想象两个特工（这里暂时不讨论二五仔的情况）在敌后接头，特工A希望获得特工B的服务点的支持（I need something bigger,XD)，但是他们互相不知道对方的身份，而且周围的每一个人都可能是敌国特务，那么他们两个要如何证明自己的身份而且确认另一方的身份呢？</p><p>最简单的办法，如果他们两个人知道一个共同的秘密<del>(比如在训练营中有人刚开始就被gang了)</del>，那么他们只要共同说出这个秘密就行了。当然，对暗号也是可以的。</p><p>但是因为周围都可能是间谍，所以一旦他们的秘密被人偷听到那么就是十分危险的，所以他们不能说出这个秘密。这种情况下如果他们还想保证安全进行身份确认的话，就需要引入一个权威第三方，这里我们就说是<code>MI6</code>(军情六处，前段时间看了王牌特工感觉还不错)。</p><p>因为军情六处掌握着所有特工的身份信息，所以理论上两个接头的特工只需要向<code>MI6</code>发送一个身份认证请求就好了。</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>特工A用自己的<code>身份识别编码的hash</code>作为密钥加密自己请求的<code>时间戳</code>和，以及自己的<code>代号和一串随机字符串（都是明文）</code>发给MI6，希望能从MI6处获得自己的身份证明确认。</p><p>也就是说</p><pre class="line-numbers language-none"><code class="language-none">特工A的请求&#x3D;“&#123;时间戳&#125;特工A身份编码hash”+“代号”+“随机字符串”。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>{时间戳}特工A身份编码hash意思是用<code>特工A身份编码hash</code>加密的时间戳，后文的公式都如此。</p></blockquote><p>MI6接收到这条信息后，先看到特工A的<code>代号</code>从而在档案库中调出<code>特工A的身份识别编码并进行hash运算</code>，用这个<code>hash</code>后的编码解密接收到的信息，得到特工A的<code>请求时间</code>和<code>随机字符串</code>。因为理论上只有特工A拥有自己的身份码，所以如果信息可以被解密，那么就说明特工A证实了自己的身份。</p><p>这时候MI6先生成了两把相同的<code>身份验证密钥</code>：在之后发送返回信息时，<strong>一把用特工A的身份识别编码hash进行加密</strong>，<strong>另一把则用MI6自己的身份识别编码的hash值进行加密</strong>。</p><p>之后MI6向特工A发送了两个东西：用于后续和MI6认证的<code>凭证</code>（这个凭证是用<code>MI6的身份识别编码hash</code>加密的，里面包含了特工A的<code>相关信息</code>和用MI6身份识别编码hash加密的<code>身份验证密钥</code>）；以及<strong>用特工A的身份识别编码hash</strong>加密的<code>身份验证密钥</code>，<code>时间戳</code>以及当时特工A发送的<code>随机字符串</code>。</p><p>也就是说：</p><pre class="line-numbers language-none"><code class="language-none">凭证&#x3D;&#123;特工A相关信息，身份验证密钥&#125;MI6身份验证码hashMI6的回复&#x3D;凭证；&#123;身份验证密钥，时间戳，随机字符串&#125;特工A身份编码hash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>特工A拿到了返回信息之后，首先用自己的身份识别编码hash解密其中一个数据包（肯定是用相同密钥加密的那个），从中提取出MI6返回给自己的<code>密钥</code>，又通过提取出的<code>随机字符串</code>确定了MI6的可信，<code>时间戳</code>让他确定了这个返回信息不是被伪造的。</p><p>之后他继续向MI6请求，希望能够在特工B的服务点获得支持。因此特工A向MI6发送了上一次接收到的用于和MI6认证的<code>凭证</code>，以及另外一个用<code>从MI6返回的身份验证密钥</code>加密的数据包，里面包含了特工A的<code>身份信息</code>，<code>时间戳</code>以及明文传输的特工B服务的相关信息。</p><pre class="line-numbers language-none"><code class="language-none">特工A的请求&#x3D;凭证；&#123;特工A身份信息，时间戳&#125;身份验证密钥+“特工B服务相关信息”<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>MI6从特工A发送的数据中看到了A的识别<code>凭证</code>，用MI6自己的身份识别编码hash解密之后发现了自己之前生成的<code>身份验证密钥</code>，再用这把解密出的身份验证密钥(套娃！)解密另一组特工A发来的信息，提取出了特工A的身份信息及时间戳从而确定了A的身份。</p><p>因为MI6已经认证了特工A的身份凭证，之后只需要确认A有这个权限，而且帮助特工A和特工B进行身份认证就好了。</p><p>这时候MI6又给了特工A两个<code>身份识别密钥</code><strong>（注意！这里是识别密钥！）</strong>：<strong>一个用于A向B证明自己的身份，一个用于帮助A确定B的身份</strong>。这两个密钥中用于<code>帮助A确定B身份的密钥</code>，又使用<code>B的身份识别编码hash</code>来加密，同时被加密的还有特工A的相关信息从而组成了一个**<code>票据</code>**；这样一来就算假的特工B收到了这个票据也会因为缺少真正B特工的身份识别编码hash从而无法解开这个票据。另外一个密钥则用之前发送过的<code>给特工A的密钥加密</code>，之后和票据一起发送给特工A。</p><pre class="line-numbers language-none"><code class="language-none">票据&#x3D;&#123;身份识别密钥，账号A的信息&#125;特工B的身份识别码hashMI6的回复&#x3D;票据；&#123;身份识别密钥&#125;身份验证密钥<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>特工A在收到这个加密密钥之后用之前（指一开始验证身份的时候）自己从MI6获得的身份验证密钥解密，从而提取出用于请求特工B服务的身份识别密钥。票据则保存用于之后和特工B的认证及服务。</p><p>值得一提的是，这里票据中特工A的信息可不单单是身份信息，还包含了特工A的权限。</p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>特工A获得了从MI6处得到的票据和加密密钥（这个时候加密密钥已经被解密）之后开始与特工B接头。</p><p>特工A向特工B发送了用<code>身份识别密钥</code>加密的特工A的身份信息，时间戳；还有票据。</p><pre class="line-numbers language-none"><code class="language-none">特工A发送&#x3D;票据；&#123;特工A身份信息，时间戳&#125;身份识别密钥<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>特工B收到后首先用自己的身份识别码hash解密<code>票据</code>，从中提取出特工A的信息（以及他所申请的服务），和<code>身份识别密钥</code>；再用<code>解密出的身份识别密钥</code>解密（又套娃，艹）特工A发送的信息，获得了特工A的身份信息和时间戳。</p><p>这样经过两次验证之后，特工B终于相信特工A是可信的。这时候特工B需要向特工A证明他就是那个收到了特工A信息的B(好冷的笑话)，于是特工B用解密出的<code>身份识别密钥</code>加密了时间戳发送给特工A。</p><pre class="line-numbers language-none"><code class="language-none">特工B发送&#x3D;&#123;时间戳&#125;身份识别密钥<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>特工A在接受到信息后用相同的密钥解密出时间戳信息，从而确定特工B就是那个B，然后愉快的交♂易就开始了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kerberos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>费曼学习法</title>
      <link href="/posts/4717.html"/>
      <url>/posts/4717.html</url>
      
        <content type="html"><![CDATA[<h2 id="理查德·费曼学习法"><a href="#理查德·费曼学习法" class="headerlink" title="理查德·费曼学习法"></a>理查德·费曼学习法</h2><h3 id="如果你不能用简单的语言来解释它，说明你没有很好地理解它。"><a href="#如果你不能用简单的语言来解释它，说明你没有很好地理解它。" class="headerlink" title="如果你不能用简单的语言来解释它，说明你没有很好地理解它。"></a>如果你不能用简单的语言来解释它，说明你没有很好地理解它。</h3><h3 id="–Somebody"><a href="#–Somebody" class="headerlink" title="–Somebody"></a>–Somebody</h3><p><img src="https://fishbed.easy233.top/ab26656071e44f9b9663183c98225cd0_th.jpeg" alt="理查德·费曼"></p><p>也就是说，如果你想要理解一个比较难懂的概念，或者是想要确保自己已经完全了解了一个东西，那么最好能用最简单的话去给一个完全没接触过这方面东西的人讲明白。</p><p>如果在解释的过程中，发现被卡住，或者必须用一些复杂的术语，那就一定程度上说明你还没有完全掌握这个概念。</p><p>这也正是费曼学习法的核心思想。</p><p>费曼认为：<strong>I couldn’t reduce it to the freshman level.That means we really don’t understand it.</strong></p><p>如果我不能把一个概念讲得让一个大学新生也能听懂，那就说明我自己也是一知半解的。</p><p>费曼的老师Wheller，也曾经说过：<strong>One can only learn by teaching.</strong></p><p>一个人只有通过教学，才能学会什么。</p><p>从本质上来讲，费曼技巧就是强调教学相长；是一种以“教学”促进“学习”的学习策略。</p><p>费曼技巧有四个简单步骤：</p><pre class="line-numbers language-none"><code class="language-none">1. 选择一个概念；2. 把它教给完全不懂的另外一个人；3. 如果卡壳，回到原始材料；4. 回顾后简化语言表达（可选）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当然，这里我们只是以概念举个栗子，并不是说所有东西都是可以生搬硬套进去的。知识的深度和讲解难度在一定程度上真的是成反比的，如果真的完全按照这个来弄，可能自己的准备时间是自己讲授时间的五倍以上。</p><p>那你可能就会说了，既然性价比这么低，为什么我们还要用这种技巧呢？</p><p>在我个人看来，想要充分地、合理地运用这种学习方法，最重要的就是知道什么地方该用，什么地方不该用（当然，如果个人精力充足的话，当然推荐坚持使用）。</p><p>我举个例子吧，就拿我们学习C语言来说，C语言的各种数据结构以及操作方法是完全可以使用这种办法的，但是如果只是一个很简单的变换屏幕颜色，在只是需要使用方法而不需要知道内部实现方法的时候，就完全可以只是阅读一下技术文档，拿来用就行了。</p><p>虽然我们经常不知道到底什么重要，什么在当前情况下不重要，这样就经常导致我们偏离学习主干线，去深究一些“不太重要”的东西。对于这种情况，我们就需要一个人能指导我们学习了，也就是说，经常和别人交流，尤其是那些比你强的。</p><p>同样，在一些基础概念学习的时候，使用费曼学习法绝对是事半功倍的，这点可以从我们学习这么多年上学的过程中得到很明显的印证。如果自己学习程度只是中上等，我们在给别人讲题的时候，会发现别人在问到一些点的时候，我们会突然答不出来，或者解释的时候前后文矛盾。这时候我们就会去翻书，去翻笔记，两个人再商量着解决这个问题，到最后这个问题完全被你们消化了，解决了，同时，对于这道题对应的知识点，你也就完全理解了，并且会印象颇深。</p><blockquote><p>PS：为什么我要说是中上等呢，因为上等的肯定完全理解了，不然他成绩不会那么好；至于别的，又经常没人问。（笑）</p></blockquote><p>对于高数这种“基础学科”，经常需要我们掌握某种定义，某种思想。那么我们怎么确定自己已经完全理解这种思想了呢？答案之一就是费曼学习法。</p><p>再扩展到我们计算机学科的学习上，在我们学习一门新的语言的时候，掌握基础定义，数据结构，算法，语言特性等等……这些与我们日后学习严密相关的东西的时候，使用这种方法绝对性价比极高。</p><p>这时候我希望你能再回到上面花一小段时间仔细看看，结合你当前的学习经历，思考一下。毕竟我讲的都是我个人的感受，如果你也真的想学会这种方法，那就可以像我一样，给别人讲出来，告诉他们你对这个学习方法的思考，告诉他们你的思想，并且在自己的学习生活中，应用它！</p><p><del>我相信之前像我说的这样的学习方法你们肯定也听过不少，各种专家的学习方法报告会，你们肯定听的更多。但是，我可以肯定，你们-没有去真正实践，或者说，你们没有真正进行思考（不然，我们也就不会在这里相遇了，是吧）。</del></p><p>推荐阅读：<a href="https://blog.csdn.net/liwei16611/article/details/89816693">https://blog.csdn.net/liwei16611/article/details/89816693</a></p><p>推荐观看：<a href="https://www.bilibili.com/video/av12639100?t=319">https://www.bilibili.com/video/av12639100?t=319</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 费曼学习法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机中的抽象</title>
      <link href="/posts/18781.html"/>
      <url>/posts/18781.html</url>
      
        <content type="html"><![CDATA[<h2 id="注意：此篇文章为我自己的读书笔记，里面所包含的观点可能有些偏差，而且我本人的知识储备可能并不足以讲明白这个。阅读时一定不要被我带进沟里。"><a href="#注意：此篇文章为我自己的读书笔记，里面所包含的观点可能有些偏差，而且我本人的知识储备可能并不足以讲明白这个。阅读时一定不要被我带进沟里。" class="headerlink" title="注意：此篇文章为我自己的读书笔记，里面所包含的观点可能有些偏差，而且我本人的知识储备可能并不足以讲明白这个。阅读时一定不要被我带进沟里。"></a>注意：此篇文章为我自己的读书笔记，里面所包含的观点可能有些偏差，而且我本人的知识储备可能并不足以讲明白这个。阅读时一定不要被我带进沟里。</h2><p>较为简单的理解来说，所谓抽象就是通过现象看本质，或者通过个别找一般。</p><p>这就是一个总体的概念，但是放在计算机学科来讲，这个概念要更复杂一点，在计算机学科中，抽象也被称为模型化。</p><p>我们从编程的角度来看。首先，假定我们是一个阅读别人代码的学习者，那么我们从别人的代码中分析某一段代码的用途，即为一次抽象，在这里，我们是把一段代码抽象成一个功能。之后，我们假定我们是一个开发者，那么我们把自己的目标转化为代码，就是由抽象到“形象”（大概是这个意思）。</p><p>那么我们现在可以大致地简单地理解抽象：抽象就是一个“功能”或者一个“需要”，而不用我们去理解底层到底是怎么运行的。就像是你会使用一台咖啡机而不用去管内部是怎么运行的一样，咖啡机所提供的就是“冲咖啡”功能的抽象。</p><p>让我们回到计算机的操作系统上来，我们已经知道一个大概念可以分拆成很多个小概念，就像是一台发动机里面有很多很多小零件一样。那么，不同层次的抽象也就组成了一个很大的系统。</p><p>对于一个电脑小白来说，他不需要知道电脑底层是怎么运行的，甚至不需要知道电脑内部有什么部件，他只需要知道鼠标左键双击就能打开文件（只是举个栗子）完全不需要知道内部是怎么运行的。那么他所使用的就是最顶层的抽象：计算机。只不过最顶层的抽象下层的抽象以及更下一级的抽象直至最终的硬件设备，共同完成了这个任务（从这个方面来讲的话，所谓人机交互，就是对机器功能的抽象）。</p><p><img src="https://fishbed.easy233.top/image-20201014145326478.png" alt="计算机系统提供的一些抽象"></p><p>现在我们来理解一下图1-18里面的几个抽象。</p><h4 id="1-文件"><a href="#1-文件" class="headerlink" title="1. 文件"></a>1. 文件</h4><p>为什么说文件是I/O设备的抽象呢？这里我想到了一句话：“Linux系统里，万物皆文件”。这里，我们把文件仅仅限定于I/O设备这些硬件设备的文件，而不是我们平常见到的一个个.txt之类的文件。我们电脑上，屏幕，鼠标，键盘，打印机等等大量的与计算机进行数据交换的设备都可以称为I/O设备。而文件是一系列的字节序列,它向应用程序提供了一个统一的视角，来看待系统中各式各样的I/O设备。也就是说，对于操作系统而言，键盘不再是键盘，而是一个可以“产生字符的文件”。所以说，我们要从操作系统的角度来思考这些抽象。</p><h4 id="2-虚拟内存（虚拟存储器）"><a href="#2-虚拟内存（虚拟存储器）" class="headerlink" title="2.  虚拟内存（虚拟存储器）"></a>2.  虚拟内存（虚拟存储器）</h4><p>在不同的书里，对这个概念有不同的翻译，个人更倾向于虚拟内存。从图中可以看到虚拟内存包含主存硬件和I/O设备。那我们就从这点开始着手分析。</p><p>虚拟内存定义：<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/101812?fr=aladdin">https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/101812?fr=aladdin</a></p><p><a href="https://blog.csdn.net/zjf280441589/article/details/43875947">https://blog.csdn.net/zjf280441589/article/details/43875947</a></p><p>虚拟内存为每个进程提供了一个大的、一致的、私有的地址空间;</p><p>它将内存看成是存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在主存与磁盘中来回交换数据。</p><p>为每个进程提供一致的地址空间，简化了存储管理,保护每个进程的地址空间不被其他进程破坏。</p><p>这个一致性和私有性是很有意思的，但是我现在还无法理解这里面的精妙之处，只能放下以后研究了。</p><p>虚拟内存是Windows 为作为内存使用的一部分硬盘空间。虚拟内存在硬盘上其实就是为一个硕大无比的文件，文件名是PageFile.Sys。当计算机因为内存耗尽而运行缓慢时，虚拟内存便会承担一部分内存的工作（这也就从一定程度上解释了为什么使用固态硬盘的电脑在内存超高占用时速度往往快于使用机械硬盘的，而且固态硬盘性能越强效果越好）。</p><p>这么一看，虚拟内存包含主存硬件和I/O设备就很好理解了。</p><h4 id="3-进程"><a href="#3-进程" class="headerlink" title="3.  进程"></a>3.  进程</h4><p>进程是操作系统对正在运行的程序的一种抽象。一个系统可以运行多个进程，而每个进程好像在独占使用硬件。一段程序的运行最少需要三个基础硬件：CPU，内存，I/O设备。在一个进程运行的时间段内，进程在操作系统看来就是一个“程序”，对于计算机操作者来说，我们看到一个正在运行的程序，但是我们完全不用在意它的内部是怎么运行的。</p><p><img src="https://fishbed.easy233.top/image-20201014145404408.png" alt="任务管理器中的进程"></p><p>因为操作系统已经借由“进程”这个抽象为我们做了这些工作。</p><h4 id="4-虚拟机"><a href="#4-虚拟机" class="headerlink" title="4.  虚拟机"></a>4.  虚拟机</h4><p>简单来讲，如果我们在具有了“进程”这个抽象所包含的所有东西的前提上，又有了操作系统，那么我们就拥有了一台“计算机”。虚拟机提供的是对整台计算机的抽象，包括操作系统，处理器和程序。</p><p>让我们来回忆一下我们是怎么创建一个虚拟机的：下载ISO镜像-》使用Vmware或者Virtualbox来安装镜像-》分配硬件给虚拟机-》安装自己需要的程序。我们就像是使用一台真正的电脑那样来使用自己的虚拟机，甚至我们把虚拟机当做真实的电脑，而电脑只是为了启动虚拟机而已。</p><blockquote><p>总是感觉抽象就像是一台巨大机器上的一个小小的交互窗口，所有的功能皆汇集于一个小小的操作界面上。抽象真是一个抽象的概念呢。</p><blockquote><p>你这人说话怎么自带emoji啊。–by 栋梁哥。</p><blockquote><p>我TM这一千多字都写的是个啥啊，只有我自己才能看懂吧！！！！！！！23333<br><del>算了，反正也没人看。</del></p></blockquote></blockquote></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 《深入理解计算机系统》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从爬图虫入手学习多线程实战</title>
      <link href="/posts/62062.html"/>
      <url>/posts/62062.html</url>
      
        <content type="html"><![CDATA[<p>《从爬虫入手学习多线程 原理分析部分》里我们对Python的多线程原理进行了分析，这次我们就直接拿一个爬虫脚本来进行实践。</p><p>上一篇的传送门： <a href="https://thewind-rises.github.io/posts/44617.html">PORTAL</a></p><p>阅读这篇文章需要的知识基础：</p><blockquote><p>Python多线程，爬虫基础</p><p>requests库的基础方法</p><p>os库的基础方法和二进制文件写入方式</p><p>re库基础方法</p><p>正则匹配基础原理</p><p>time库基础方法</p></blockquote><h2 id="一．爬虫原理简单分析"><a href="#一．爬虫原理简单分析" class="headerlink" title="一．爬虫原理简单分析"></a>一．爬虫原理简单分析</h2><p>我们现在大多数用的网络爬虫都基于第三方的requests库，经过测试，这个的确比原装的<code>urllib</code>库要快一点点（再说我也习惯了）。</p><p>爬虫的获取页面行为就类似于我们平常打开浏览器访问网页的行为：触发请求-&gt;发请求包给服务器-&gt;服务器返回包（简单来讲就是这个步骤，实际上更复杂）。</p><p>但爬虫和浏览器的不同点就在于：浏览器会把服务器的返回包解析成我们能看懂的正常的网页，而爬虫只是单纯的接收数据包。</p><p>我们可以通过代码提取出服务器返回包内我们需要的信息，对其进行各种我们需要的操作（比如下载，和格式化数据保存）。</p><p>总体来说，一个简单的爬虫由以下几个方面构成：</p><pre class="line-numbers language-none"><code class="language-none">1. 请求器，用于向目标服务器请求并返回数据包。2. 数据筛选器，用于从数据包中提取我们需要的数据3. 数据处理器，用于处理筛选器筛选好的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本上来说拥有以上三个组件，一个简单的小小爬虫就做好了。所以记好这三个部分，但是我们的爬虫因为要用到多线程，所以就不止这三个部分啦，还有一个线程调度器。</p><p>接下来就是代码实例分析部分了。实际上这也就是个入门还不到的爬虫，用的各种东西也都是最基础的。因为目标网站几乎把我们平常爬取可能遇到的问题（比如各种访问验证）都解决掉了，这才是真正强的大佬。</p><p>有兴趣可以看看大佬的网站分析：<a href="https://www.oysterqaq.com/archives/850">https://www.oysterqaq.com/archives/850</a></p><h2 id="二．爬虫实例"><a href="#二．爬虫实例" class="headerlink" title="二．爬虫实例"></a>二．爬虫实例</h2><h4 id="1-请求器"><a href="#1-请求器" class="headerlink" title="1.请求器"></a>1.请求器</h4><p>我个人是很不喜欢一些博客直接贴上代码草草说两句剩下就让自己体会的，所以我会先分析一下源码。但是个人建议还是最后自己对着代码分析一下，因为可能有些地方我感觉很简单就直接略过了。</p><img src="https://fishbed.easy233.top/image-20201013205610412.png" alt="请求器" style="zoom:150%;" /><p>爬虫的请求器和<code>requests库</code>密切相关，在这里我们仅仅使用了<code>requests.get()</code>方法，因为不用登陆所以也就没必要使用<code>session()</code>方法。最后就把我们获取到的返回包给赋给了test对象。</p><pre class="line-numbers language-none"><code class="language-none">requests.get()方法参数如下：requests.get(url, headers&#x3D;(), params&#x3D;())常用的有：requests.get(url, headers&#x3D;())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> headers就是我们打开浏览器按F12查看能获取到的</p><p><img src="https://fishbed.easy233.top/image-20201013205739677.png" alt="headers"></p><p>如果不懂各项参数的可以自己百度一下，我在这里就不分析了。</p><p>但是注意我们应该把<code>headers</code>信息写到一个<code>dict字典</code>里面。</p><p>至于代码里的<code>Root_url</code>和<code>url</code>都要自己去获取，但这不是这篇的目的，如何获取和分析目标网站会在另外的文章里。</p><p>最后在分析筛选器之前我要先列举几个对象（这里为test，以后统称test对象）的方法。</p><pre class="line-numbers language-none"><code class="language-none">test.text：返回headers中的编码解析的结果，可以通过test.encoding &#x3D; &#39;gbk&#39;来变更解码方式test.content：返回二进制结果test.json()：返回JSON格式，可能抛出异常test.status_code：返回请求状态码，可以用于debugtest.raw：返回原始socket respons，需要加参数stream&#x3D;True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上还有不少，例如下面图中的，如果有需要可以直接调用（所以说要学好英语啊，学好之后看字面意思就能直接写，看官方文档也方便），我在这里就不一一列举了。</p><p><img src="https://fishbed.easy233.top/image-20201013205947530.png" alt="各类方法"></p><p>参考文档：</p><p><a href="https://2.python-requests.org/zh_CN/latest/index.html">https://2.python-requests.org//zh_CN/latest/index.html</a></p><p>其实这些东西看着都很简单，但是如果不自己动手写，尝试运用，那么也只是知道而已。永远记住一句话：<strong>实践出真知</strong>。</p><h4 id="2-数据筛选器"><a href="#2-数据筛选器" class="headerlink" title="2. 数据筛选器"></a>2. 数据筛选器</h4><p>这个数据筛选器主要使用了<code>re库</code>，也就是通过正则匹配的方法来获取我们需要的数据，实际上还可以使用<code>Beautiful Soup库</code>，但这里没必要。之后可以<code>re</code>配合<code>Beautiful Soup库</code>更好地收集我们需要的数据。</p><p>其实我学了正则之后的经验就是：遇到需要匹配的数据先找数据特征，之后再着手编写表达式。而正则不是抽象的，其实很形象，你给他放上什么匹配条件他就会去匹配（哪怕是一个空格），虽然正则里面的匹配条件很多，但是没必要全都背下来，掌握几个常用的，其余的用到时候再翻手册也行。</p><p>正则学习参考：</p><p><a href="https://www.cnblogs.com/chuxiuhong/p/5885073.html%EF%BC%88%E8%BF%99%E4%B8%AA%E6%88%91%E6%84%9F%E8%A7%89%E5%86%99%E7%9A%84%E7%9B%B8%E5%BD%93%E5%A5%BD%EF%BC%89">https://www.cnblogs.com/chuxiuhong/p/5885073.html（这个我感觉写的相当好）</a></p><p><a href="https://www.cnblogs.com/wenwei-blog/p/7216102.html">https://www.cnblogs.com/wenwei-blog/p/7216102.html</a></p><p><a href="https://cloud.tencent.com/developer/article/1114817">https://cloud.tencent.com/developer/article/1114817</a></p><p>在线正则匹配测试，贼有用的：</p><p><a href="http://tool.oschina.net/regex/">http://tool.oschina.net/regex/</a></p><p>在这个脚本里我只用到了<code>re.compile()</code>和<code>re.findall()</code>方法，不会的话就还是去看看我推荐的那三个博客吧。</p><p><img src="https://fishbed.easy233.top/image-20201013210302258.png" alt="筛选器"></p><p>实际上如果你对着代码分析，你就会发现这个筛选器实际上包含了数据收集和数据加工两部分，并且只获取了png格式的图片(jpg格式的还有一个另脚本，略微修改一下就行，我是懒得写判断条件了，再说两个脚本同时跑还是多进程呢)。</p><p><img src="https://fishbed.easy233.top/clip_image009.gif" alt="你说是吧（笑）"></p><p>数据收集就是用正则实现的，之后把匹配好的数据存入一个列表里面。</p><p>数据加工就是为了把不能用的部分修剪掉，就如下图所示。因为不同的网站会不一样，所以说这个只是学习一下思路和方法就好。</p><p><img src="https://fishbed.easy233.top/clip_image011.jpg" alt="数据加工"></p><p>数据加工用到的方法就是<code>replace()</code>方法，需要注意引号问题，还有就是这个是用来处理字符串的，注意输入数据的类型。</p><p><code>replace()</code>方法学习：<a href="https://www.runoob.com/python3/python3-string-replace.html">https://www.runoob.com/python3/python3-string-replace.html</a></p><p>但是这样的处理后的URL仍然不能直接使用，需要拼接<code>Root_url</code>。这个需要看情况对待，可能别的网站不需要这样。</p><p>总之来说，爬图虫就是要能直接访问到图片的源地址才能进行下载。</p><h4 id="3-数据处理器"><a href="#3-数据处理器" class="headerlink" title="3.数据处理器"></a>3.数据处理器</h4><p><img src="https://fishbed.easy233.top/clip_image013.jpg" alt="数据处理器"></p><p>对于一个爬图虫来说，数据处理就是把图片的数据流保存进入文件中，并且根据图片格式加上合适的后缀名，并且数据流是二进制的（在这个爬图虫里，img就是下载的图片）。</p><p>既然涉及到文件的保存，那么就要引入另一个模块：<code>os</code></p><p>OS模块参考文档：<a href="https://www.runoob.com/python3/python3-os-file-methods.html">https://www.runoob.com/python3/python3-os-file-methods.html</a></p><p>文件读写参考：<a href="https://www.cnblogs.com/ymjyqsx/p/6554817.html">https://www.cnblogs.com/ymjyqsx/p/6554817.html</a></p><p>别看上面的代码那么多，实际上也就只是创建文件夹和是否成功的各种判断而已，没什么大不了的，千万不要被吓到。</p><p>第61行的<code>num = num + 1</code>是为了迭代地给文件命名，之前定义过<code>num = 0</code></p><p>注意：一定要明确文件路径的写的方法，不然就会报错，推荐使用“/”反斜杠</p><h4 id="4-线程调度器"><a href="#4-线程调度器" class="headerlink" title="4.线程调度器"></a>4.线程调度器</h4><p><img src="https://fishbed.easy233.top/clip_image015.jpg" alt="线程调度器"></p><p>总算到多线程部分了，其实如果看过我的上一篇文章，关于多线程部分应该就不会有问题了，这个地方只是实现了一个很简单的多线程，通过四个线程分别下载四个不同界面，自然不存在任务分配问题，除了需要在文件写入的时候加锁以外就没什么了。</p><p>但其实这种方法的效率很低，因为没能实现线程的最大化利用，如果有的页面提前下载完了，那么这个线程就闲置了。这个问题在我之后研究进程池的时候获得了解决。多进程真好玩！</p><h4 id="5-任务"><a href="#5-任务" class="headerlink" title="5.任务"></a>5.任务</h4><p>如果你真的想学写爬虫并且运用多线程的话，不妨试试这个任务：实现线程的最大化利用。</p><p>你可以尝试把所有的图片URL放入一个线程池，让线程自己去取得工作然后完成、更可以挑战一下用多个线程下载同一个文件。如果你能把这个弄明白了，那么一定能提升自己对文件操作的理解以及培养自己的编程思维。</p><h4 id="6-代码包和自己的一点小感悟"><a href="#6-代码包和自己的一点小感悟" class="headerlink" title="6.代码包和自己的一点小感悟"></a>6.代码包和自己的一点小感悟</h4><p>链接：<a href="https://pan.baidu.com/s/1JluQHwDaSK4LhnNdYeA4Rg">https://pan.baidu.com/s/1JluQHwDaSK4LhnNdYeA4Rg</a></p><p>提取码：q4dv </p><p>这里面有多线程和单线程的爬图虫，可以对照着研究一下。之后我不会更新这些脚本，如果出现问题的话可以尝试自己去debug，相信我，这也是很能提高自己的。</p><p>其实经过这么一段时间的研究，我也发现一个问题就是，Python的多线程实际上就只是一个美丽的梦而已，就实质性的速度提升来说，很多方面是不如多进程的，甚至在一些任务上还不如单线程。</p><p>当然，我也没全盘否定多线程。多线程更适用于网页请求以及I/O读写操作，多进程适用于CPU密集型操作。还是贴一下官方文档吧：</p><p><img src="https://fishbed.easy233.top/clip_image017.jpg" alt="官方文档"></p><p>可以看到它不是一无是处，只是我们在很多开发场景上暂时用不到，或者说用到了意义不大。</p><p>当然，其实最可能的就是我仍然没有能够全面地了解Python的多线程执行，还是太菜了啊。</p><p>如果看过我的这两篇文章之后你仍然对Python的多线程或者多进程兴趣浓厚，那么不妨看看官方文档：<a href="https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/chapter1/index.html">https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/chapter1/index.html</a></p><p><img src="https://fishbed.easy233.top/clip_image019.jpg" alt="列表"></p><p>哪怕我研究了一段时间也只是揭开了Python的并行计算的冰山一角而已，这也告诫我们不要小看任何一门语言，除非你已经确定自己完全了解了它。永远要保持一颗谦卑的心，然后用自己最大的努力去学好它。</p><p>其实还有一点就是，想学好一门语言，最好的办法就是不断去研习官方文档，然后去自己写代码实践。</p><h2 id="三．结语"><a href="#三．结语" class="headerlink" title="三．结语"></a>三．结语</h2><p>花了这么三四天总算是把这上下两篇写好了，也是耽误了不少时间，中途又对文章修修改改，有些不合适的地方还要斟酌一番。我的理念是：既然写出来了就要对里面的知识负责，草草了事的话不止是对自己的不负责，更是对别人的不负责。如果不是为了让更多人获益的话，那就不用写博客只用写自己能看懂的笔记就行了。</p><p>在这里我要再次感谢帮助我的学长和同学，如果没有他们的话，不知道这两篇文章会是个什么样子呢。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python,多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从爬图虫入手学习多线程（原理分析）</title>
      <link href="/posts/44617.html"/>
      <url>/posts/44617.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>学Python不写爬虫和咸鱼有什么区别！！！！by：Noob_宅</p></blockquote><p><img src="https://fishbed.easy233.top/%E4%BB%8E%E7%88%AC%E5%9B%BE%E8%99%AB%E5%85%A5%E6%89%8B%E5%AD%A6%E4%B9%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%EF%BC%89/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python.png" alt="人生苦短，我用Python">  </p><p>阅读此篇文章需具备的知识基础：Python基础（最少要学习过基础教程，能读懂代码），入门级的数据结构基础（知道队列的概念即可）。最好学过C语言，了解一些CPU的工作原理。</p><p>当然，如果后三者不太了解的话也不是不行，我会尽量在文中以简明易懂的方式解释，了解的可以跳过解释部分。</p><h2 id="一．前言"><a href="#一．前言" class="headerlink" title="一．前言"></a>一．前言</h2><p>之前曾经拿别人的脚本学习了一下网络爬图虫怎么写，但是写好后运行起来一直嫌慢。这两天正巧有空学了一下Python多线程，感觉Python的多线程特别适合爬虫这种IO密集型的操作。</p><p>所谓的IO就是input和output，输入和输出。或者称为读写，总之就是对数据流的操作。</p><p>（这里我们摘取廖雪峰老师的教程中的一段来解释一下IO密集型和计算密集型：</p><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017631469467456">https://www.liaoxuefeng.com/wiki/1016959663602400/1017631469467456</a></p><p>计算密集型 vs. IO密集型</p><p>是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和IO密集型。</p><p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p><p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p><p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p><p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。）</p></blockquote><p>看完这个应该就能很好地理解为什么爬虫适合多线程了，这里一定要清楚记得IO密集型的特性，后文会多次提到。</p><h2 id="二．学习多线程（基于threading库）"><a href="#二．学习多线程（基于threading库）" class="headerlink" title="二．学习多线程（基于threading库）"></a>二．学习多线程（基于threading库）</h2><p>当时我学习多线程其实主要是从视频上学习基础知识的，之后又看了很多博客，结合我对计算机硬件和系统的一些粗浅了解，我也写出了自己的一些见解，可能讲的不深。</p><p>我当时看的视频：<a href="https://www.bilibili.com/video/av16944429">https://www.bilibili.com/video/av16944429</a></p><p>没错，就是哔哩哔哩。这充分说明了B站是学习的地方（手动滑稽）。个人感觉讲的挺好的，值得一看。</p><p>这里我们就以视频中代码为例来慢慢展示多线程。</p><h3 id="1-创建线程，线程监控和join-方法"><a href="#1-创建线程，线程监控和join-方法" class="headerlink" title="1.  创建线程，线程监控和join()方法"></a>1.  创建线程，线程监控和join()方法</h3><p>First.py</p><p><img src="https://fishbed.easy233.top/%E4%BB%8E%E7%88%AC%E5%9B%BE%E8%99%AB%E5%85%A5%E6%89%8B%E5%AD%A6%E4%B9%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%EF%BC%89/First.py.png" alt="First.py">  </p><p>PEP8规范不是没道理的，的确看着舒服很多。</p><p>这段代码里主要使用了如下方法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 创建线程，主要参数target（用于指定子线程工作的位置，不能为空）;name（用于指定线程的名称，可以为空）;args（用于向线程工作的地方，也就是target处传递参数，可以为空）。</span>thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 启动线程，就像是发动汽车的引擎一样，必须有的步骤。</span>threading<span class="token punctuation">.</span>active_count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 激活的线程数</span>threading<span class="token punctuation">.</span><span class="token builtin">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 查看激活的线程名</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 查看当前正在运行线程（同时显示了线程名）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://fishbed.easy233.top/%E4%BB%8E%E7%88%AC%E5%9B%BE%E8%99%AB%E5%85%A5%E6%89%8B%E5%AD%A6%E4%B9%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%EF%BC%89/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="运行结果">  </p><p>这里也贴上运行的结果进行对照，可以很明确的看出各项参数对应的信息。</p><p>实际上，在我后来编写爬虫脚本的时候最经常用到的方法为<code>current_thread()</code>，至于原因……自己编写一个脚本就知道啦（其实主要就是为了debug和测试）。</p><p>接下来就是一个重点啦：<code>join()</code>方法</p><p>简单来讲<code>Join()</code>方法是用来判断<strong>指定线程</strong>是否执行完毕的，如果执行完毕的话，代码才会继续向下执行，否则就一直维持执行。为什么我们说是指定线程呢？？？</p><p>观察代码不难发现，<code>added_thread.join()</code>，对应的就是我们创建的<code>T1线程</code>。或者更简单点<code>added_thread线程</code>，以后我们会创建更多的线程，<strong>join()前面是谁，那么就判断谁</strong>。这点也要着重记忆一下，以后会很有用。</p><p>还记得那张代码的运行结果吗？？？这里我们将<code>added_thread.join()</code>句注释掉，再运行这个脚本，猜猜会发生什么？？？这里可以先自己想一想，分析一下再往下看。</p><p><img src="https://fishbed.easy233.top/%E4%BB%8E%E7%88%AC%E5%9B%BE%E8%99%AB%E5%85%A5%E6%89%8B%E5%AD%A6%E4%B9%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%EF%BC%89/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="运行结果">  </p><p>乍看一下两张图没什么区别，但是仔细观察的话发现注释掉<code>join()</code>语句之后，程序先打印了<strong>all done</strong>，之后才是<strong>T1 finished</strong>。这里就说明了join()语句的重要作用，如果执行一个程序需要把子线程的数据返回给主线程执行的话，join()语句就是必不可少的啦。</p><p>其实仔细想想还能发现一个问题：<strong>Python的线程有主线程和子线程，但是两者是分开工作的互不影响，主线程执行完毕并不会使子线程停止。</strong>想通这点的话，就能慢慢接触到Python多线程的本质了，并且以后的编程中也会经常遇到这个问题。</p><p>至此就粗浅的讲解了一下多线程的基础方法，我们再来做一下回顾。</p><p>Python的线程有主线程和子线程，但是两者是分开工作的互不影响，主线程执行完毕并不会使子线程停止。所以说需要使用join()方法来判断线程是否结束，只有结束后才会继续向下运行。如果需要保证所有都运行完毕的话可以设置一个线程调度器。</p><p>至于什么是线程调度器，下一章会讲。</p><h3 id="2-queue队列和线程调度器"><a href="#2-queue队列和线程调度器" class="headerlink" title="2.  queue队列和线程调度器"></a>2.  queue队列和线程调度器</h3><p>Second.py</p><p><img src="https://fishbed.easy233.top/%E4%BB%8E%E7%88%AC%E5%9B%BE%E8%99%AB%E5%85%A5%E6%89%8B%E5%AD%A6%E4%B9%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%EF%BC%89/Second.py.png" alt="Second.py">  </p><p>写多线程其实会经常遇到需要子线程向主线程返回结果的情况，但是线程是没有返回值的，如果使用全局变量又会引出很多问题并且不适合代码量较多的情况，这时候队列就能派上用场了。</p><p>使用队列需要引入<code>queue库</code>，在这里我们只简单的讲解一下queue的几个主要方法（实际上原因是我本人对这个也不是太理解，数据结构苦手啊QAQ）。想更多了解的话可以看看网上的各种博客还有教学视频。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">queue<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 创建队列，特点：先入先出（解释：可以理解为一条流水线，先进入的零件会先被组装好之后输出）</span><span class="token comment"># 在这里我们以q代指这个队列（或者说q这个对象已经是一个队列了）</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 将数据存入队列中</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 将数据从队列中取出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>（PS：好丢人啊，感觉写了不如不写）</p></blockquote><p>接下来就是另一个重点了，<strong>线程调度器</strong>。</p><p>有的时候我们需要开辟多个线程，但是如果重复创建线程，启动线程，操作线程，监控线程无疑是效率很低的，但是如果有一个总领的调度器那就很简单了，很容易实现批量创建指定数目线程，并且对线程进行总体管理（暂时没有研究如何对单个线程进行管理，我一般采取的思路是在线程工作的地方对单个子线程进行管理）。</p><p>以下是一个简单的创建四个子线程的线程调度器的代码：</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">threads <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># args用于向分线程工作的地方传参，同时指定i的值，使线程在指定地方(即job)工作</span>t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>job<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>threads<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token keyword">for</span> thread <span class="token keyword">in</span> threads<span class="token punctuation">:</span>thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 重点：所有线程运行结束后再向下运行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然比较简单，但是这个实现了4个线程的批量创建和简单线程控制，我在写爬虫的时候也用到了这个调度器，还是直接复制粘贴的（所以说啊，存存代码是很有意义的）。</p><p>我们来分析一下这个调度器，首先我们定义了一个threads列表用于储存线程（对象），之后创建并启动了四个线程，通过<code>for thread in threads</code>对每一个线程实现了join()方法进行控制。程序的运行结果如下：</p><p><img src="https://fishbed.easy233.top/%E4%BB%8E%E7%88%AC%E5%9B%BE%E8%99%AB%E5%85%A5%E6%89%8B%E5%AD%A6%E4%B9%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%EF%BC%89/%E7%BB%93%E6%9E%9C.png" alt="结果">  </p><p>最后的数据为程序运行所用时间。可以自己试着分析一下这个程序的结果。</p><p>接下来我们进入下一章节。</p><h3 id="3-真·伪多线程，快or慢"><a href="#3-真·伪多线程，快or慢" class="headerlink" title="3.  真·伪多线程，快or慢"></a>3.  真·伪多线程，快or慢</h3><p>可能初看这个标题会比较懵逼，但是这也就是我要讲的Python多线程的<strong>实质</strong>。</p><p>初听多线程可能就是感觉程序会在多个线程上运行，从而让程序执行变快。如果你就是这么认为而且从代码的运行结果中也感觉出来了这一点，那么图样图森破，程序设计师的小伎俩又一次成功了。</p><p>实际上Python的多线程是一种障眼法：程序本质上还只是运行在CPU的一个线程上，但是程序通过不停地在多个线程中进行切换，同时切换的速度很快，从而造成了一种多线程的假象。实际上程序还是同时只运行一个线程。</p><p>这也就引出了一个问题：多线程其实有的时候不是那么的有效率，甚至还不如单线程。可能这时候你就想直接左上角或者右上角了。但是别急，回忆一下前言提到的计算密集型和IO密集型的概念，如果忘了的话再回去看个两三次。</p><p>是不是意识到了什么？？？？</p><p>毫无疑问，最适合Python多线程的地方其实是IO密集型的操作。</p><p>如果还不理解什么是IO密集型的话那我就举个栗子。</p><blockquote><p>—————————栗子的分割线—————————————-</p><p><img src="https://fishbed.easy233.top/clip_image014.gif" alt="假栗子"></p><p><img src="https://fishbed.easy233.top/clip_image016.gif" alt="爪巴"></p><p>拿错了……</p><p><img src="https://fishbed.easy233.top/clip_image018.gif" alt="真栗子"></p><p>比如说你（CPU）和别人聊天，但是和你聊天的人并不会你说一句他就立刻回一句（除非你本人是个妹子而对面是一只单身狗，或者是你基（姬）友），但是你一次只能做一件事（CPU线程是唯一的）。这时候你有两个选择：一直拿着手机或者电脑等待对方发信息（线程一直在处理但是CPU在等待），或者回复完对方的信息之后就直接去干别的事，等到出现消息提示音再回来看信息（将CPU释放处理其他工作）。</p><p>—————————-栗子的分割线————————————-</p></blockquote><p>可能我比较笨，让你看的更晕了，那么接下来我还是引用廖老师的原句来解释一下这个问题吧。</p><blockquote><p>———————————–专业的分割线——————————-</p><p>这类任务（IO密集）的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。</p><blockquote><p>好了，总算解释完了IO密集型的问题。那就继续吧，接下来我们来说一下为什么多线程的效率有时候不如单线程。</p></blockquote><blockquote><p>接下来还是廖老师的原句，先体会一下。</p></blockquote><p>线程切换</p><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？</p><p>我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。</p><p>如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型，或者批处理任务模型。</p><p>假设你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以幼儿园小朋友的眼光来看，你就正在同时写5科作业。</p><p>但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。</p><p>所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。</p><p>—————————–专业与非专业的分割线——————————</p></blockquote><p>实际上线程切换还和一个东西密切相关：GIL（全局解析器锁）</p><p>那么什么是全局解析器锁呢？这里我引用一个博客，写的很不错，很好的分析了并行和并发，以及Python多线程的切换问题。</p><p>链接：<a href="https://blog.csdn.net/weixin_41594007/article/details/79485847">https://blog.csdn.net/weixin_41594007/article/details/79485847</a></p><p>GIL即全局解释器锁（global interpreter lock），每个线程在执行时候都需要先获取GIL，保证同一时刻只有一个线程可以执行代码，即<strong>同一时刻只有一个线程使用CPU</strong>，也就是说多线程并不是真正意义上的同时执行。</p><p>但是加锁也是有代价的，都需要CPU进行操作，所以说一定程度上会拖慢程序运行的时间，但总归上是利大于弊的。</p><p>这里我也总结一下：进程（线程）切换这个问题实际上就关乎多线程（进程）和单线程效率的判断，总有一个最适区间。通过我自己编写其它测试脚本发现，即使是CPU计算密集型，如果跑的数据够大够多，那么多进程的效率要远高于多线程（这个数据和核心数目有关系），同时多线程和单线程差距又不大，但是多线程仍旧比单线程慢，这说明多进程还是强（可能有点题外话了，在之后的文章里应该会讲，如果我不咕咕咕的话）。</p><p>更多关于速度问题的探讨可以参考这篇博客:<a href="https://blog.csdn.net/u011519550/article/details/89857063">https://blog.csdn.net/u011519550/article/details/89857063</a></p><h3 id="4-GIL原理的初步探究"><a href="#4-GIL原理的初步探究" class="headerlink" title="4.  GIL原理的初步探究"></a>4.  GIL原理的初步探究</h3><p>Fourth.py</p><p><img src="https://fishbed.easy233.top/clip_image020.jpg" alt="Fourth.py"></p><p>这个脚本就是为了探讨GIL的问题：GIL的切换方式，或者说切换条件。</p><p>运行后可以观察到：脚本每次运行，总有两三个线程的启动和结束顺序不一样。这也和GIL的释放锁特性有关：在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL 。Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL），而Python 2.x，则是tickets计数达到100。</p><p>在多线程爬虫脚本的编写过程中我也被这个问题困扰了很久，因为不知道线程在切换的时候，网络IO是否还在继续运行。所以我在爬虫脚本里下载图片的地方前后各添加了一个判断当前线程的函数。</p><p><img src="https://fishbed.easy233.top/clip_image022.jpg" alt="添加函数"></p><p>最后程序运行的结果也是让我大吃一惊</p><p><img src="https://fishbed.easy233.top/clip_image024.jpg" alt="线程不同"></p><p><img src="https://fishbed.easy233.top/clip_image026.jpg" alt="线程相同"></p><p>下载图片的线程和写入图片的线程有时候居然是不一样的，根据原理分析的话答案可能就是：如果下载图片的时间超过一个固定阈值，那么GIL就会释放当前线程，让下一个线程接手上一个线程的任务（真实接盘侠），此时上一个线程去执行其它任务。大体上只从结果分析就是这样，如果真的想要完全知道，那就只能去读一读方法源码了，以后会读一下的，不然也没无从谈起学会了Python。</p><p>越是研究就越是为语言编写者的智慧所折服，这玩意真的是一个圣诞节假期就能搞出来的东西吗？？？Guido van Rossum（吉多·范罗苏姆）是外星人吧。</p><p>无力吐槽。不过还是想吐槽一下切换方式。一个渣男追一个妹子，追到一定时间就放弃这个妹子去找下一个，然后还有人去接盘，真实的窒息。理科男流下了单身狗的泪水。</p><h3 id="5-LOCK-线程锁"><a href="#5-LOCK-线程锁" class="headerlink" title="5.  LOCK 线程锁"></a>5.  LOCK 线程锁</h3><p>别问我为什么这个脚本叫做Third.py，我现在也很迷QAQ</p><p><img src="https://fishbed.easy233.top/clip_image028.jpg" alt="Third.py"></p><p>这一个脚本就是为了解释Python多线程中锁的作用。</p><p>如果你需要多个线程来处理一个数据，或者上个线程的结果要作为下一个线程的输入，那么加一把锁就是很重要的了。（多线程模式下用这个运算数据纯属脱裤子放屁，有时候直接单线程更好其实）</p><p>还是讲一下关于锁的部分的各种方法吧：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 创建一个锁，注意threading小写，Lock首字母大写</span>threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 为线程加上锁，表示这个线程不能继续使用，需要等待工作完成</span>threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 释放锁，表示任务已完成，可以继续切换线程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际在运用过程中，锁是一个很有意思的东西。</p><p>在IO情况下，如果是磁盘IO那就必须加锁，除非你指定文件句柄（指定句柄一般用于多个线程向一个文件内写入数据，相当厉害的操作）。如果是网络IO那就可以不加锁（至少在下载图片看来是这样，这个在我的脚本里也有体现）。</p><p>关于锁其实还有很多要研究，但是我目前只遇到了磁盘IO和网络IO的情况，所以这方面的研究就少了一点，以后补上吧。</p><h3 id="6-代码包"><a href="#6-代码包" class="headerlink" title="6.  代码包"></a>6.  代码包</h3><p>上述所有的代码我都已经打包好了，有需要的话可以自己download下来自己运行一下，全都是基于Python3.7进行编译。</p><p>链接：<a href="https://pan.baidu.com/s/1dRAFNN1047PUBKty-esXMw">https://pan.baidu.com/s/1dRAFNN1047PUBKty-esXMw</a></p><p>提取码：txsn </p><p>至此我们就完成了编写多线程脚本的知识储备，希望你能自己对着代码敲一敲，自己也研究一下，可能就会发现很多有意思的东西。当然我本人也是正在学习的过程中，可能文章里面有些地方会有纰漏。如果有发现这样的错误可以联系我，邮箱地址是：<a href="mailto:&#x38;&#57;&#50;&#x31;&#x37;&#53;&#55;&#x33;&#54;&#64;&#113;&#x71;&#46;&#x63;&#111;&#x6d;">&#x38;&#57;&#50;&#x31;&#x37;&#53;&#55;&#x33;&#54;&#64;&#113;&#x71;&#46;&#x63;&#111;&#x6d;</a>，前面就是QQ号，想共同探讨也可以加我QQ，但请写好备注。</p><p>接下来我就会拿爬虫脚本来进行分析了，有兴趣的可以继续看看。</p><p>感谢我的学长和同学在我写这篇文章的过程中对我的帮助，给我提供了很多宝贵的意见。</p><p>此文章为之前的搬运，创作日期为2019.05.不知道多少号。（XD）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python,多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frp内网穿透</title>
      <link href="/posts/27423.html"/>
      <url>/posts/27423.html</url>
      
        <content type="html"><![CDATA[<p>随着工具越来越多，越发感觉电脑内存不够用，但是又没办法加内存，更不可能天天背一个台式机跑来跑去（十多公斤的玩意会死人的啊！！！！！！），所以决定直接把要用到的虚拟机全部放在台式机上，然后内网穿透出去直接远程搞，想想真舒服！！！</p><h2 id="Frp介绍"><a href="#Frp介绍" class="headerlink" title="Frp介绍"></a>Frp介绍</h2><p>frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。</p><h3 id="为什么使用Frp"><a href="#为什么使用Frp" class="headerlink" title="为什么使用Frp"></a>为什么使用Frp</h3><p>通过在具有公网 IP 的节点上部署 frp 服务端，可以轻松地将内网服务穿透到公网，同时提供诸多专业的功能特性，这包括：</p><ul><li><p>客户端服务端通信支持 TCP、KCP 以及 Websocket 等多种协议。</p></li><li><p>采用 TCP 连接流式复用，在单个连接间承载更多请求，节省连接建立时间。</p></li><li><p>代理组间的负载均衡。</p></li><li><p>端口复用，多个服务通过同一个服务端端口暴露。</p></li><li><p>多个原生支持的客户端插件（静态文件查看，HTTP、SOCK5 代理等），便于独立使用 frp 客户端完成某些工作。</p></li><li><p>高度扩展性的服务端插件系统，方便结合自身需求进行功能扩展。</p></li><li><p>服务端和客户端 UI 页面。</p></li></ul><blockquote><p>以上内容来自：<a href="https://github.com/fatedier/frp/blob/dev/README_zh.md">https://github.com/fatedier/frp/blob/dev/README_zh.md</a></p></blockquote><h2 id="需要的材料"><a href="#需要的材料" class="headerlink" title="需要的材料"></a>需要的材料</h2><ul><li><p>FRP</p></li><li><p>一台内网主机（之后称为客户机）</p></li><li><p>一台具有公网IP的主机（之后称为服务机，可以是阿里云之类的或者是国外的VPS）</p></li></ul><p>这里我推荐使用国内的主机，毕竟延迟低。</p><p>我使用的是一台Kali虚拟机作为客户机，一台Centos系统的阿里云服务器作为服务机，都是linux_amd64的。</p><h2 id="Frp安装以及简单配置"><a href="#Frp安装以及简单配置" class="headerlink" title="Frp安装以及简单配置"></a>Frp安装以及简单配置</h2><h3 id="1-下载FRP"><a href="#1-下载FRP" class="headerlink" title="1.  下载FRP"></a>1.  下载FRP</h3><p>从GitHub上下载FRP程序。地址：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p><p><img src="https://fishbed.easy233.top/image-20200926151342321.png" alt="下载"></p><p>一般是这两个，不过根据自己的需要进行选择。</p><p>将下载之后的tar包解压，解压指令为：<code>tar -xzvf frp_0.28.0_linux_amd64.tar.gz</code></p><p>之后进入解压之后的路径。</p><h3 id="2-简单配置客户机和服务机"><a href="#2-简单配置客户机和服务机" class="headerlink" title="2. 简单配置客户机和服务机"></a>2. 简单配置客户机和服务机</h3><h4 id="a-配置客户机"><a href="#a-配置客户机" class="headerlink" title="a)  配置客户机"></a>a)  配置客户机</h4><p><img src="https://fishbed.easy233.top/image-20200926151524977.png" alt="配置指令"></p><p>这里我已经将所有frps文件删除了，只剩下frpc文件。</p><p>使用文本编辑器打开frpc.ini文件，修改箭头位置的IP为你在公网的服务器的IP。</p><p><img src="https://fishbed.easy233.top/image-20200926160148500.png" alt="frpc.ini"></p><p>端口不用变，默认为7000，之后退出即可。</p><h4 id="b-配置服务机"><a href="#b-配置服务机" class="headerlink" title="b)  配置服务机"></a>b)  配置服务机</h4><p>服务机只有一个端口的设置，默认为7000，如果需要修改必须同时修改客户机上的设置。</p><p><img src="https://fishbed.easy233.top/image-20200926160214863.png" alt="frps.ini"></p><p>保存之后退出。</p><h4 id="c-启动服务"><a href="#c-启动服务" class="headerlink" title="c)  启动服务"></a>c)  启动服务</h4><p>切换到frp文件夹内，在服务机上运行<code>./frps -c ./frps.ini</code>指令。之后服务机就会开始监听7000端口上来自全网的frp访问。</p><p><img src="https://fishbed.easy233.top/image-20200926160404386.png" alt="服务启动"></p><p>切换到frp文件夹内，在客户机上运行<code>./frpc -c ./frpc.ini</code>指令。出现这样的反馈便说明已经成功内网穿透了。</p><img src="https://fishbed.easy233.top/image-20200926160454925.png" alt="客户端服务"  /><p><img src="https://fishbed.easy233.top/image-20200926160500742.png" alt="服务端显示成功"></p><p>d)  通过SSH服务访问客户机</p><p>指令：<code>ssh username@公网主机IP -p 6000</code></p><p>端口需要和客户机配置文件里remote_port一样。</p><p><img src="https://fishbed.easy233.top/image-20200926160729654.png" alt="通过SSH指令登陆成功"></p><p>相当成功。</p><p>之所以用<code>cmder</code>来演示是因为我想强调配置好frp后只需要使用ssh连接便可以访问客户机，而无需一直使用服务机的SSH服务去连接。</p><p>Enjoy！</p><h2 id="进阶版配置"><a href="#进阶版配置" class="headerlink" title="进阶版配置"></a>进阶版配置</h2><p>经过简单配置后就frp可以使用了，但是我们想要的就是这么简单的效果吗？？？</p><p>FRP之所以是神器，就是因为它有超多的可选配置功能，在这里我仍然使用SSH连接进行演示。但是我要加强他的连接安全性。毕竟，谁都不想被别人猜解出自己的frp服务器后被白嫖吧。</p><h3 id="i-配置服务机"><a href="#i-配置服务机" class="headerlink" title="i.  配置服务机"></a>i.  配置服务机</h3><p>和之前不同的是，完全配置文件中有超多的选项，如果你没看过Github上的官方文档一定会懵逼的。这里我们只以使用TCP连接的SSH的配置为例。</p><p><img src="https://fishbed.easy233.top/image-20200926161410207.png" alt="frps.ini"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Bind_addr <span class="token operator">=</span> <span class="token number">0.0</span>.0.0 <span class="token comment">#这个不用动</span>Bind_port <span class="token operator">=</span> <span class="token number">7374</span> <span class="token comment">#这个可以根据自己的喜好修改，但是对应的客户机也需要修改，因为客户机是发送请求到这个端口之后服务机才会给他分配端口</span>Bind_udp_port <span class="token operator">=</span> <span class="token number">7001</span> <span class="token comment">#如果你不使用UDP连接的话就可以不用管</span>Kcp_bind_port <span class="token operator">=</span> <span class="token number">7374</span> <span class="token comment">#这个因为可以设置和bind_port相同，我就直接设置一样了</span>Vhost_http_port <span class="token operator">=</span> <span class="token number">8081</span> <span class="token comment">#</span>Vhost_gttps_pprt <span class="token operator">=</span> <span class="token number">8082</span> <span class="token comment">#这两个是用于设置http和https协议端口用的，因为如果不改就会报错，我就随便设置了两个，反正也不用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://fishbed.easy233.top/image-20200926161719218.png" alt="frps.ini"></p><p>这张图里面的参数最重要的就是token，客户机和服务机的token必须一样，如果不一样就会发生验证错误问题。同样可以自己设置成自己的特色token。另外一个值得注意的是7500端口，这个是图形化管理界面，如下图所示：</p><p><img src="https://fishbed.easy233.top/image-20200926161742895.png" alt="图形化页面"></p><p>在浏览器里访问服务机IP后面加上7500端口就可以进入，用户名和密码默认为admin，同样可以通过修改配置文件参数来进行改变，最好不要用弱口令。</p><p><img src="https://fishbed.easy233.top/image-20200926161839964.png" alt="frps.ini"></p><p>这里重要的是allow_ports 和max_pool_count两个设置。前者用于设置客户机可用的端口（因为客户机的端口都是映射过来的），后者解释起来比较麻烦，还是贴官方文档</p><p><img src="https://fishbed.easy233.top/image-20200926161847743.png" alt="连接池"></p><p>个人一般设置为6，因为我一台小钢炮也需要frp，就同时开了。。。实际上影响也不大。按照顺序修改完之后，服务机的配置就结束了。</p><h3 id="ii-配置客户机"><a href="#ii-配置客户机" class="headerlink" title="ii. 配置客户机"></a>ii. 配置客户机</h3><p>这次我们使用的是完全配置文件(frpc_full.ini)，但是因为里面有过多的可选设置，所以我们有时候可能需要删掉一部分。所以在我们修改配置文件之前推荐对frpc_full.ini文件进行一次备份，如果之后想用其中某个功能，直接复制粘贴过来启用就行。</p><p>如果你是用vim打开的话，在命令行模式下执行<code>:88,243d</code>这个指令（后续可能因为frp更新导致删错东西，自己灵活变通），他会直接删除88到243行，当然，如果你删错了，回到命令行模式输入u就行。如果你不会vim指令的话，推荐学一学。真好用。</p><p>虽然删掉之后还有很多设置，不过，总归少了点。。。。更何况暂时用到的不多。</p><p><img src="https://fishbed.easy233.top/image-20200926162208220.png" alt="frpc_full.ini"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Server_addr <span class="token operator">=</span> <span class="token comment">#你的服务机IP</span>Server_port <span class="token operator">=</span> <span class="token comment">#服务机设置的监听端口</span>Token <span class="token operator">=</span> <span class="token comment">#和服务机配置文件设置必须一样，不然会授权错误。</span>admin_addr <span class="token operator">=</span> <span class="token number">127.0</span>.0.1admin_port <span class="token operator">=</span> <span class="token number">7400</span>admin_user <span class="token operator">=</span> adminadmin_pwd <span class="token operator">=</span> admin <span class="token comment">#这几个参数是客户机的图形化frp控制台，可以很方便的查看和修改参数，有需要的话可以修改。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://fishbed.easy233.top/image-20200926162456756.png" alt="SSH连接配置"></p><p>这些便是SSH连接的相关参数，其中最重要的是<code>remote_port</code>，这个参数将会告诉服务机你想要把客户机的端口给绑定到服务机的哪个端口，之后ssh连接将会使用这个参数设定的端口。</p><p>值得一提的是<code>use_encryption</code>和<code>use_compression</code>这两个参数，下面还是官方文档。</p><p><img src="https://fishbed.easy233.top/image-20200926162548509.png" alt="官方文档"></p><p>开就完事了。</p><blockquote><p>反正不要钱，多少信一点。——渡鸦12345</p></blockquote><p>至此客户机的设置结束。</p><h3 id="iii-验证"><a href="#iii-验证" class="headerlink" title="iii. 验证"></a>iii. 验证</h3><p>在服务机上frp文件夹中运行<code>./frps -c ./frps_full.ini</code>指令。</p><p>在客户机上frp文件夹中运行<code>./frps -c ./frpc_full.ini</code>指令。</p><p>注意，此时终端会被占用，如果没有报错就不存在回显，具体的运行日志需要查看frps.log和frpc.log文件，如果出现问题往这两个里面看就行。</p><p>分别访问服务机ip:7500和客户机ip:7400，如果都正常访问到，说明服务成功启动</p><p><img src="https://fishbed.easy233.top/image-20200926162710506.png" alt="服务机控制面板"></p><p><img src="https://fishbed.easy233.top/image-20200926162835369.png" alt="客户机控制面板"></p><p>之后和之前简单配置时候一样，用ssh连接指令即可直接连接。Awesome！！！！</p><p><img src="https://fishbed.easy233.top/image-20200926162956803.png" alt="SSH连接"></p><h3 id="iv-设置自启动"><a href="#iv-设置自启动" class="headerlink" title="iv. 设置自启动"></a>iv. 设置自启动</h3><p>但是我感觉这样还不完美，frp服务在运行的时候是会阻塞终端运行的，除非你多开，但是我不想让他这样，并且我还不想输那么长的指令，还想让他开机自启（懒人事多）。为了能偷懒，还要用另外一个小东西进行设置。</p><p>参考文章：<a href="https://blog.csdn.net/sinat_29963957/article/details/83591264">https://blog.csdn.net/sinat_29963957/article/details/83591264</a></p><p>文章里面只写了服务端怎么配置，不过依葫芦画瓢，也是很简单的，如果你真的不会配置，行吧。。。。</p><p><img src="https://fishbed.easy233.top/image-20200926163033734.png" alt="frapc service"></p><p>满意了吧<del>\</del>~</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul><li><p>一般常见的错误有端口无法访问，一般是因为防火墙，只需要放行特定端口就是了，如果还不行，建议把防火墙直接拆了，我就是这么干的，实在无法解决可以更换端口，那么多端口随便换就行；</p></li><li><p>No route to host。一般是因为设置错误，也有防火墙的问题，建议直接拆除；</p></li><li><p>login to server failed: authorization failed。这个就是token不一致导致的错误。</p></li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢fatedier大神开发的FRP，真的是超级厉害。</p><p>如果你有更多的使用需求的话，请去github上看官方文档研究研究，有超多玩法的。</p><blockquote><p>PS：妈耶，写这个真累。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和广告的抗争</title>
      <link href="/posts/43034.html"/>
      <url>/posts/43034.html</url>
      
        <content type="html"><![CDATA[<p>此篇为之前的博客搬运。</p><hr><p>好久没发文了，今天来除除草。</p><p>我想大家都被那些购物广告还有网页弹窗烦死了吧。那种开电脑就给你弹很多的什么每日新闻啦，今日头条啦，<code>系兄弟就来刚我啦</code>，以及某360的开机广告……真是一点营养都没有。</p><p>一般来说，广告都来自于无良软件，<code>@某360</code>。但往往一些我们经常使用的软件也有广告，毕竟大家要恰饭的嘛，于是我们也就每天继续和弹窗广告斗智斗勇。</p><p>可是根据我的观察，我发现绝大多数人在广告出现时只是点了叉叉，没错，绝大多数都是。</p><p>日常生活中我们经常见到广告的地方无非也就电脑和手机，而对于笔者这些拿电脑当吃饭家伙的人来说，使用最多的场景肯定还是电脑。那我就先从电脑上的广告过滤开始说吧。</p><p>不得不说，现在做广告的技术也是真的厉害，前段时间在别人电脑上见了一条游来游去的锦鲤，笑死我了。</p><p>一般来说，比较有良心的广告一般会在右上角显示可以设置永久不弹。但是我只想说，你在我的电脑上弹广告就是原罪。</p><p>其实想拦截这种广告很简单，但是你需要一个足够好用的弹窗拦截器。如果你正巧用的是 <code>腾讯电脑管家 </code>的话，那就很简单了。只需三步就能让电脑桌面上的弹窗显著减少。</p><h3 id="电脑系统弹窗"><a href="#电脑系统弹窗" class="headerlink" title="电脑系统弹窗"></a>电脑系统弹窗</h3><ol><li> 打开工具箱</li></ol><p><img src="https://fishbed.easy233.top/image-20200926145026992.png" alt="工具箱"></p><ol start="2"><li> 选择软件弹窗拦截</li></ol><p>这个可能需要找一下，因为每个人的位置都不太一样。</p><p><img src="https://fishbed.easy233.top/image-20200926145052456.png" alt="软件弹窗拦截工具"></p><ol start="3"><li> 在没有设立拦截的情况下界面我记得会提示让你添加要拦截的弹窗，只要把拦截项拉满就行了。</li></ol><p><img src="https://fishbed.easy233.top/image-20200926145119518.png" alt="添加拦截项"></p><p>一般来说，经过上面三步设置就能干掉80%的广告了，但是有些还是无法拦截的（应该是厂商之间的PY交易（确信）），这时候就需要我们动动鼠标，把那些弹窗手动设置永久不弹，或者是继续通过弹窗拦截中，”名单添加”和”截图添加”功能进行屏蔽了，坚持一段时间，电脑上的弹窗就统统不见了。</p><p><img src="https://fishbed.easy233.top/image-20200926145220553.png" alt="特殊拦截方式"></p><h3 id="浏览器网页弹窗"><a href="#浏览器网页弹窗" class="headerlink" title="浏览器网页弹窗"></a>浏览器网页弹窗</h3><h4 id="AdGuard"><a href="#AdGuard" class="headerlink" title="AdGuard"></a>AdGuard</h4><p>在日常使用电脑的过程中，另一个比较影响我们体验的就是网页广告了，尤其是一些盗版小说网站，我我感觉想看小说但又囊中羞涩的同学一定感受颇深。拦截这种广告，杀毒软件自带的功能就不太好用了，我们需要祭出另一个大杀器：<code>AdGuard</code>，还有<code>Ad blocker</code>。个人比较推荐AdGuard（ADB太丑了）。</p><p><img src="https://fishbed.easy233.top/image-20200926145244748.png" alt="AdGuard"></p><p>AdGuard可以实现对绝大多数网页广告的过滤，以及对弹窗广告的拦截。更强悍的是，AdGuard可以实现网页排版的恢复，而不会出现像是用杀软自带的过滤器那样的现象（会留下一个相当难看的白块）。并且AdGuard也可以实现对危险连接的拦截，谁不想让自己的信息变得很安全呢？</p><p>最最重要的是，浏览器插件版的AdGuard是完全免费的！！是完全免费的！！是完全免费的！！（白嫖真香）同时AdGuard还有电脑版和手机版（安卓和ios都有），我手机上就有这个，超好用，上网完全不担心垃圾广告，还能一定程度上拦截开屏广告（就打开软件送广告那种）。</p><p>先给你们看看效果：</p><p>AdGuard开启前：</p><p><img src="https://fishbed.easy233.top/image-20200926145332507.png" alt="广告满天飞"></p><p>AdGuard开启后：</p><p><img src="https://fishbed.easy233.top/image-20200926145349605.png" alt="给爷死！死ね！"></p><h4 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h4><p>一般来说，你在浏览器自带的扩展里就能找到，往往在菜单设置。没记错的话，QQ浏览器是叫应用广场？只要搜索安装就可以使用。</p><p>下面就以火狐的安装为例：</p><p>在菜单栏里选择附加组件项</p><p><img src="https://fishbed.easy233.top/image-20200926145535178.png" alt="附加组件"></p><p>搜索安装即可。</p><p><img src="https://fishbed.easy233.top/image-20200926145600374.png" alt="搜索"></p><p><img src="https://fishbed.easy233.top/image-20200926145618333.png" alt="安装"></p><p>至于谷歌的安装需要科学上网才能访问谷歌应用商店，所以大多数人应该是用不了的。</p><p><img src="https://fishbed.easy233.top/image-20200926145644324.png" alt="GFW永远滴神！"></p><p>当然，土豪可以选择购买软件版，这个就NB了。顺便提一下，能不能借我用用？（小声BB）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂物 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA解决Illegal mix of collations for operation  &#39;UNION&#39;问题</title>
      <link href="/posts/54858.html"/>
      <url>/posts/54858.html</url>
      
        <content type="html"><![CDATA[<p>Keywords：DVWA,Illegal mix of collations for operation ‘UNION’</p><p>今天同学在做作业的时候遇到了这个问题过来请教我。</p><p><img src="https://fishbed.easy233.top/image-20200926112446926.png" alt="问题"></p><p>之前在学习的时候没遇到过这个问题（2018年的时候我学的DVWA，后来上网查资料的时候发现这个问题在2019年下旬才开始出现，应该和PHPstudy的更新有关系，之前我用的是老版本PHPstudy一切正常，现在用新的之后也遇到了这个问题）。</p><p>本来以为很快就能解决的，结果用了一个多小时才解决掉。大多数的时间都花在了找资料还有和命令行较劲上了，后来发现命令行实在是有问题（修改过之后的值就是死活不能保存）。在github上下载的最新版本代码也不行，故决定直接自己修改DVWA的源码，反正又不是看不懂，淦。</p><p>下面是修改办法：</p><ol><li> 打开DVWA安装目录里的MySQL.php文件。</li></ol><p>一般都是WWW目录，不过我自己设置为Demo目录了，不必在意。</p><p><img src="https://fishbed.easy233.top/image-20200926112524287.png" alt="第一步"></p><ol start="2"><li> 如图所示，在$create_db这个变量的赋值语句里加上一小段</li></ol><p>COLLATE utf8_general_ci</p><p>一定要注意空格，在 <code>&#125;</code> 和<code>COLLATE</code>之间有一个空格，如果不加上就会出错。</p><p><img src="https://fishbed.easy233.top/image-20200926112600134.png" alt="步骤2"></p><p>完整的语句我也放在这里，省的复制也能复制错。</p><p>$create_db = &quot;CREATE DATABASE {$_DVWA[ &#39;db_database&#39; ]} COLLATE utf8_general_ci;&quot;;</p><ol start="3"><li> 在Setup / Reset DB页面重新建立DVWA数据库</li></ol><p><img src="https://fishbed.easy233.top/image-20200926112633711.png" alt="步骤3"></p><ol start="4"><li> 成功！</li></ol><p><img src="https://fishbed.easy233.top/image-20200926113532458.png" alt="成功执行命令"></p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><img src="https://fishbed.easy233.top/QQ图片20210402102641.jpg" alt="声明" style="zoom: 33%;" />]]></content>
      
      
      
        <tags>
            
            <tag> DVWA,MySQL排序编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEXO+GitHubpage+部署优化过程记录</title>
      <link href="/posts/5921.html"/>
      <url>/posts/5921.html</url>
      
        <content type="html"><![CDATA[<img src="https://fishbed.easy233.top/image-20200925204020538.png"/><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>咕咕咕了好久之后终于开始继续进行学习，之前的博客已经很久没有维护了，而且也是和别人一起搭建的，虽然是轻松了一点，但是上传个文章很不方便，而且后台我也懒得进，最后还是决定自己搭建一个博客。问题是，手头没有主机，没有域名，更莫得钱，幸好有大佬告诉我可以用HEXO+GitHubpage白嫖，遂决定研究。</p><h3 id="所需条件"><a href="#所需条件" class="headerlink" title="所需条件"></a>所需条件</h3><ol><li>有一台自己的PC，Windows、Linux、Mac均可。</li><li>有自己的域名或者能嫖来一个子域名。（白嫖真香</li><li>会用MarkDown语法（不会用就去学啊），自己有时间折腾。</li></ol><h3 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h3><h4 id="部署："><a href="#部署：" class="headerlink" title="部署："></a>部署：</h4><p>官方文档：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><p>博客：</p><p><a href="http://blog.haoji.me/build-blog-website-by-hexo-GitHub.html?from=xa">博客1</a></p><p><a href="https://blog.csdn.net/linton1/article/details/90137367">博客2</a></p><p>理论上来说，根据这两篇博客配置就没有什么问题，想要研究更多东西请参考官方文档。</p><h5 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h5><ol><li><p>在安装npm之后可以参考<a href="https://blog.sky03.cn/posts/42790.html#toc-heading-1">博客3</a>，先进行npm的速度优化，不然安装过程会长到你怀疑人生。</p></li><li><p>如果你对GitHub的使用不是那么熟练，那么你可以在创建仓库时参考博客2的创建过程。但是要注意的是博客2在创建仓库时有一些小的错误（详情见博客2的评论，博主在评论里指出了修改办法），这一步可以参考博客1的做法，这里我也贴上我最后的设置结果。</p></li></ol><img src="https://fishbed.easy233.top/image-20200925191920954.png"/><img src="https://fishbed.easy233.top/image-20200925192235170.png"/><img src="https://fishbed.easy233.top/image-20200925192301082.png"/><h3 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h3><h4 id="主题选择："><a href="#主题选择：" class="headerlink" title="主题选择："></a>主题选择：</h4><p>这里我推荐一个主题：hexo-theme-matery，本博客使用的也是这个主题。</p><p>GitHub项目地址：<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">https://GitHub.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><p>我讲一下我推荐这个主题的原因：</p><ol><li><p>界面称得上好看</p></li><li><p>有写的很好的中文文档，是国人开发的，而且开发程度比较完善，网上也有很多教程。如果你用一些冷门博客主题的话很有可能在个性化的时候（甚至在配置的时候）都会遇到各种问题。</p></li><li><p>配置文件基本都有中文注释，熟悉后想要自己修改设置的话根本不用参考官方文档。</p></li><li><p>懒。毕竟选主题实在是太累了，最后直接选了这个，我老选择困难症了。</p></li></ol><p>如果你选择了这个主题的话，那么你可以参考这篇文章进行个性化设置：<a href="https://blog.csdn.net/victoryxa/article/details/105841309">https://blog.csdn.net/victoryxa/article/details/105841309</a></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><p><a href="https://blog.sky03.cn/posts/42790.html#toc-heading-1">博客3</a></p><p><a href="https://zhuanlan.zhihu.com/p/69211731">B乎</a></p><h5 id="tips：-1"><a href="#tips：-1" class="headerlink" title="tips："></a>tips：</h5><p>在你对全站配置CDN加速之前，你可以先看看matery主题配置文件的最后部分。这里提供了一个全局CDN设置，可以直接加速整个仓库。</p><img src="https://fishbed.easy233.top/image-20200925201553538.png"/><p>真香。</p><h3 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h3><h4 id="工具推荐："><a href="#工具推荐：" class="headerlink" title="工具推荐："></a>工具推荐：</h4><p>md文件编辑器:Typora（怎么安装和使用就不介绍了，网上教程成吨）</p><p>图床：七牛云，GitHub图床（胜在免费，但是在国内使用体验不佳）</p><p>图片上传：PicGo-core(command-line)</p><p>好消息是在Typora里面已经集成了PicGo的接口，所以说真的是香的一批。</p><h3 id="建立图床："><a href="#建立图床：" class="headerlink" title="建立图床："></a>建立图床：</h3><p>这里以七牛云为例。</p><p>参考博客：<a href="https://www.cnblogs.com/ssgeek/p/10854839.html">https://www.cnblogs.com/ssgeek/p/10854839.html</a></p><p>如果你没有自己的域名的话，也可以绑定成白嫖的子域名，暂时没发现有什么问题，反正只是给图床用。</p><h4 id="图片上传："><a href="#图片上传：" class="headerlink" title="图片上传："></a>图片上传：</h4><p>Typora中，图片上传的配置如下：</p><img src="https://fishbed.easy233.top/image-20200925202250996.png"/><p>之所以不用PicGo-APP是因为懒得安装一个软件，而且Typora本身的接口都写得很好，设置完成之后可以直接从剪贴板插入图片并且完成上传，就免去了用图形化界面的烦恼。</p><p>下载也不用自己用命令行，直接在Typora上传服务设定中，选择PicGo-Core（command line），然后点击“下载或更新”即可。</p><p>下载完成后点击“打开配置文件”，因为我们用的是命令行模式，所以说修改信息可能比较麻烦，但是好在有官方提供的<a href="https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html#%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">文档</a>。</p><p>但是因为未知原因，通过命令行自动生成配置文件会有Bug，所以下面我还贴上我用七牛云图床时的配置文件：</p><img src="https://fishbed.easy233.top/image-20200925205408742.png"/><p>配置的相关项可以参考PicGo-APP的<a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#%E4%B8%83%E7%89%9B%E5%9B%BE%E5%BA%8A">文档</a>，命令行和图形化客户端本质上都是一样的。说不定用到后面你会爱上命令行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，HEXO+GitHubPage的博客搭建及美化优化，以及用HEXO写博客的方法就记录完毕。</p><p>如果你看到这篇文章，觉得有不明白的地方，可以到我的<a href="https://github.com/Thewind-rises/thewind-rises.GitHub.io/issues">GitHub issus</a>界面提出问题，如果我看到的话就会回答。</p><p>觉得这篇文章帮到你的话也不妨给我的<a href="https://github.com/Thewind-rises/thewind-rises.GitHub.io">GitHub项目主页</a>点一个star。</p><p>谢谢。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Blog部署优化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
